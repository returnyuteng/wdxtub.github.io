<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="编程,Python," />





  <link rel="alternate" href="/atom.xml" title="小土刀" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="这里收集了一些深入 python 机制的内容。">
<meta property="og:type" content="article">
<meta property="og:title" content="Python 编程思想">
<meta property="og:url" content="http://wdxtub.com/2016/03/24/thinking-in-python/index.html">
<meta property="og:site_name" content="小土刀">
<meta property="og:description" content="这里收集了一些深入 python 机制的内容。">
<meta property="og:image" content="http://wdxtub.com/images/14588486364401.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14588486530973.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14588486595605.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14588486859304.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14588486997857.jpg">
<meta property="og:image" content="http://wdxtub.com/media/14521096832549/tip1.png">
<meta property="og:image" content="http://wdxtub.com/images/14588487955418.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14588488054814.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14588488145630.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14588488380987.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14588488493152.jpg">
<meta property="og:image" content="http://wdxtub.com/images/14588488582446.jpg">
<meta property="og:updated_time" content="2016-03-24T19:52:07.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python 编程思想">
<meta name="twitter:description" content="这里收集了一些深入 python 机制的内容。">
<meta name="twitter:image" content="http://wdxtub.com/images/14588486364401.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 4016951,
      author: '博主'
    }
  };
</script>

  <title> Python 编程思想 | 小土刀 </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <!-- hexo-inject:begin --><!-- hexo-inject:end --><script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=59042340";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <div style="display: none;">
    <script src="http://s6.cnzz.com/stat.php?id=1260625611&web_id=1260625611" type="text/javascript"></script>
  </div>





  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">小土刀</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Agony is my triumph</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-work">
          <a href="/2016/09/11/work-page" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-pencil"></i> <br />
            
            作品
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tech">
          <a href="/2009/09/11/tech-page" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-battery-full"></i> <br />
            
            技术
          </a>
        </li>
      
        
        <li class="menu-item menu-item-life">
          <a href="/1990/09/11/life-page" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-bolt"></i> <br />
            
            生活
          </a>
        </li>
      
        
        <li class="menu-item menu-item-booklist">
          <a href="/1997/09/11/booklist-page" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-diamond"></i> <br />
            
            书单
          </a>
        </li>
      
        
        <li class="menu-item menu-item-thanks">
          <a href="/thanks" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-gift"></i> <br />
            
            关于我
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Python 编程思想
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-24T15:36:15+08:00" content="2016-03-24">
              2016-03-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Technique/" itemprop="url" rel="index">
                    <span itemprop="name">Technique</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/24/thinking-in-python/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/24/thinking-in-python/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
              &nbsp; | &nbsp;
              <span class="page-pv"><i class="fa fa-file-o"></i>
              <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
              </span>
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>这里收集了一些深入 python 机制的内容。</p>
<a id="more"></a>
<hr>
<h2 id="浅谈-Python-的-with-语句"><a href="#浅谈-Python-的-with-语句" class="headerlink" title="浅谈 Python 的 with 语句"></a>浅谈 Python 的 with 语句</h2><p>with 语句是从 Python 2.5 开始引入的一种与异常处理相关的功能（2.5 版本中要通过 <code>from __future__ import with_statement</code> 导入后才可以使用），从 2.6 版本开始缺省可用（参考 What’s new in Python 2.6? 中 with 语句相关部分介绍）。with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>要使用 with 语句，首先要明白上下文管理器这一概念。有了上下文管理器，with 语句才能工作。</p>
<p>下面是一组与上下文管理器和with 语句有关的概念。</p>
<p>上下文管理协议（Context Management Protocol）：包含方法 <code>__enter__()</code> 和 <code>__exit__()</code>，支持该协议的对象要实现这两个方法。</p>
<p>上下文管理器（Context Manager）：支持上下文管理协议的对象，这种对象实现了<br><code>__enter__()</code> 和 <code>__exit__()</code> 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。</p>
<p>运行时上下文（runtime context）：由上下文管理器创建，通过上下文管理器的 <code>__enter__()</code> 和 <code>__exit__()</code> 方法实现，<code>__enter__()</code> 方法在语句体执行之前进入运行时上下文，<code>__exit__()</code> 在语句体执行完后从运行时上下文退出。with 语句支持运行时上下文这一概念。</p>
<p>上下文表达式（Context Expression）：with 语句中跟在关键字 with 之后的表达式，该表达式要返回一个上下文管理器对象。</p>
<p>语句体（with-body）：with 语句包裹起来的代码块，在执行语句体之前会调用上下文管<br>理器的 <code>__enter__()</code> 方法，执行完语句体之后会执行 <code>__exit__()</code> 方法。</p>
<h3 id="基本语法和工作原理"><a href="#基本语法和工作原理" class="headerlink" title="基本语法和工作原理"></a>基本语法和工作原理</h3><p>with 语句的语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">with</span> context_expression [<span class="keyword">as</span> target(s)]:</div><div class="line">    <span class="keyword">with</span>-body</div></pre></td></tr></table></figure>
<p>这里 context_expression 要返回一个上下文管理器对象，该对象并不赋值给 as 子句中的 target(s) ，如果指定了 as 子句的话，会将上下文管理器的 <code>__enter__()</code> 方法的返回值赋值给 target(s)。target(s) 可以是单个变量，或者由“()”括起来的元组（不能是仅仅由“,”分隔的变量列表，必须加“()”）。</p>
<p>Python 对一些内建对象进行改进，加入了对上下文管理器的支持，可以用于 with 语句中，比如可以自动关闭文件、线程锁的自动获取和释放等。假设要对一个文件进行操作，使用 with 语句可以有如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">r'somefileName'</span>) <span class="keyword">as</span> somefile:</div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> somefile:</div><div class="line">        <span class="keyword">print</span> line</div><div class="line">        <span class="comment"># ...more code</span></div></pre></td></tr></table></figure>
<p>这里使用了 with 语句，不管在处理文件过程中是否发生异常，都能保证 with 语句执行完毕后已经关闭了打开的文件句柄。如果使用传统的 try/finally 范式，则要使用类似如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">somefile = open(<span class="string">r'somefileName'</span>)</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> somefile:</div><div class="line">        <span class="keyword">print</span> line</div><div class="line">        <span class="comment"># ...more code</span></div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    somefile.close()</div></pre></td></tr></table></figure>
<p>比较起来，使用 with 语句可以减少编码量。已经加入对上下文管理协议支持的还有模块 threading、decimal 等。</p>
<p>PEP 0343 对 with 语句的实现进行了描述。with 语句的执行过程类似如下代码块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">context_manager = context_expression</div><div class="line">exit = type(context_manager).__exit__  </div><div class="line">value = type(context_manager).__enter__(context_manager)</div><div class="line">exc = <span class="keyword">True</span>   <span class="comment"># True 表示正常执行，即便有异常也忽略；False 表示重新抛出异常，需要对异常进行处理</span></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        target = value  <span class="comment"># 如果使用了 as 子句</span></div><div class="line">        <span class="keyword">with</span>-body     <span class="comment"># 执行 with-body</span></div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="comment"># 执行过程中有异常发生</span></div><div class="line">        exc = <span class="keyword">False</span></div><div class="line">        <span class="comment"># 如果 __exit__ 返回 True，则异常被忽略；如果返回 False，则重新抛出异常</span></div><div class="line">        <span class="comment"># 由外层代码对异常进行处理</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exit(context_manager, *sys.exc_info()):</div><div class="line">            <span class="keyword">raise</span></div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    <span class="comment"># 正常退出，或者通过 statement-body 中的 break/continue/return 语句退出</span></div><div class="line">    <span class="comment"># 或者忽略异常退出</span></div><div class="line">    <span class="keyword">if</span> exc:</div><div class="line">        exit(context_manager, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</div><div class="line">    <span class="comment"># 缺省返回 None，None 在布尔上下文中看做是 False</span></div></pre></td></tr></table></figure>
<ol>
<li>执行 context_expression，生成上下文管理器 context_manager</li>
<li>调用上下文管理器的 <code>__enter__()</code> 方法；如果使用了 as 子句，则将 <code>__enter__()</code> 方法的返回值赋值给 as 子句中的 target(s)</li>
<li>执行语句体 with-body</li>
<li>不管是否执行过程中是否发生了异常，执行上下文管理器的 <code>__exit__()</code> 方法，<code>__exit__()</code> 方法负责执行“清理”工作，如释放资源等。如果执行过程中没有出现异常，或者语句体中执行了语句 break/continue/return，则以 None 作为参数调用 <code>__exit__(None, None, None)</code> ；如果执行过程中出现异常，则使用 sys.exc_info 得到的异常信息为参数调用 <code>__exit__(exc_type, exc_value, exc_traceback)</code></li>
<li>出现异常时，如果 <code>__exit__(type, value, traceback)</code> 返回 False，则会重新抛出异常，让with 之外的语句逻辑来处理异常，这也是通用做法；如果返回 True，则忽略异常，不再对异常进行处理</li>
</ol>
<h2 id="Python程序的执行原理"><a href="#Python程序的执行原理" class="headerlink" title="Python程序的执行原理"></a>Python程序的执行原理</h2><p>Python先把代码(.py文件)编译成字节码，交给字节码虚拟机，然后虚拟机一条一条执行字节码指令，从而完成程序的执行。</p>
<p>字节码在Python虚拟机程序里对应的是PyCodeObject对象。</p>
<p>.pyc文件是字节码在磁盘上的表现形式。</p>
<p>PyCodeObject对象的创建时机是模块加载的时候，即import。</p>
<p>Python test.py会对test.py进行编译成字节码并解释执行，但是不会生成test.pyc。</p>
<p>如果test.py加载了其他模块，如import util，Python会对util.py进行编译成字节码，生成util.pyc，然后对字节码解释执行。</p>
<p>如果想生成test.pyc，我们可以使用Python内置模块py_compile来编译。</p>
<p>加载模块时，如果同时存在.py和.pyc，Python会尝试使用.pyc，如果.pyc的编译时间早于.py的修改时间，则重新编译.py并更新.pyc。</p>
<p>Python代码的编译结果就是PyCodeObject对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    PyObject_HEAD</div><div class="line">    int co_argcount;        /* 位置参数个数 */</div><div class="line">    int co_nlocals;         /* 局部变量个数 */</div><div class="line">    int co_stacksize;       /* 栈大小 */</div><div class="line">    int co_flags;   </div><div class="line">    PyObject *co_code;      /* 字节码指令序列 */</div><div class="line">    PyObject *co_consts;    /* 所有常量集合 */</div><div class="line">    PyObject *co_names;     /* 所有符号名称集合 */</div><div class="line">    PyObject *co_varnames;  /* 局部变量名称集合 */</div><div class="line">    PyObject *co_freevars;  /* 闭包用的的变量名集合 */</div><div class="line">    PyObject *co_cellvars;  /* 内部嵌套函数引用的变量名集合 */</div><div class="line">    /* The rest doesn’t count <span class="keyword">for</span> hash/cmp */</div><div class="line">    PyObject *co_filename;  /* 代码所在文件名 */</div><div class="line">    PyObject *co_name;      /* 模块名|函数名|类名 */</div><div class="line">    int co_firstlineno;     /* 代码块在文件中的起始行号 */</div><div class="line">    PyObject *co_lnotab;    /* 字节码指令和行号的对应关系 */</div><div class="line">    void *co_zombieframe;   /* <span class="keyword">for</span> optimization only (see frameobject.c) */</div><div class="line">&#125; PyCodeObject;</div></pre></td></tr></table></figure>
<p>加载模块时，模块对应的PyCodeObject对象被写入.pyc文件，格式如下：</p>
<p><img src="/images/14588486364401.jpg" alt=""></p>
<h3 id="分析字节码"><a href="#分析字节码" class="headerlink" title="分析字节码"></a>分析字节码</h3><p>Python提供了内置函数compile可以编译Python代码和查看PyCodeObject对象，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">s = ”hello”</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> s</div><div class="line"></div><div class="line">func()</div></pre></td></tr></table></figure>
<p>在Python交互式shell里编译代码得到PyCodeObject对象:</p>
<p><img src="/images/14588486530973.jpg" alt=""></p>
<p>dir(co)已经列出co的各个域，想查看某个域直接在终端输出即可：</p>
<p><img src="/images/14588486595605.jpg" alt=""></p>
<p>test.py的PyCodeObject</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">co.co_argcount    0</div><div class="line">co.co_nlocals     0</div><div class="line">co.co_names       (‘s’, ’func’)</div><div class="line">co.co_varnames    (‘s’, ’func’)</div><div class="line">co.co_consts      (‘hello’, &lt;code object func at 0x2aaeeec57110, file ”test.py”, line 3&gt;, None)</div><div class="line">co.co_code        ’d\x00\x00Z\x00\x00d\x01\x00\x84\x00\x00Z\x01\x00e\x01\x00\x83\x00\x00\x01d\x02\x00S’</div></pre></td></tr></table></figure>
<p>Python解释器会为函数也生成的字节码PyCodeObject对象，见上面的co_consts[1]</p>
<p>func的PyCodeObject</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">func.co_argcount   0</div><div class="line">func.co_nlocals    0</div><div class="line">func.co_names      (‘s’,)</div><div class="line">func.co_varnames   ()</div><div class="line">func.co_consts     (None,)</div><div class="line">func.co_code       ‘t\x00\x00GHd\x00\x00S’</div></pre></td></tr></table></figure>
<h3 id="执行字节码"><a href="#执行字节码" class="headerlink" title="执行字节码"></a>执行字节码</h3><p>Python虚拟机的原理就是模拟可执行程序再X86机器上的运行，X86的运行时栈帧如下图：</p>
<p><img src="/images/14588486859304.jpg" alt=""></p>
<p>假如test.py用C语言来实现，会是下面这个样子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *s = “hello”;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(“%s\n”, s);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    func();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Python虚拟机的原理就是模拟上述行为。当发生函数调用时，创建新的栈帧，对应Python的实现就是PyFrameObject对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">typedef struct _frame &#123;</div><div class="line">    PyObject_VAR_HEAD</div><div class="line">    struct _frame *f_back;    /* 调用者的帧 */</div><div class="line">    PyCodeObject *f_code;     /* 帧对应的字节码对象 */</div><div class="line">    PyObject *f_builtins;     /* 内置名字空间 */</div><div class="line">    PyObject *f_globals;      /* 全局名字空间 */</div><div class="line">    PyObject *f_locals;       /* 本地名字空间 */</div><div class="line">    PyObject **f_valuestack;  /* 运行时栈底 */</div><div class="line">    PyObject **f_stacktop;    /* 运行时栈顶 */</div><div class="line">    …….</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么对应Python的运行时栈就是这样子：</p>
<p><img src="/images/14588486997857.jpg" alt=""></p>
<p>执行test.py的字节码时，会先创建一个栈帧，以下用f表示当前栈帧，执行过程注释如下：</p>
<p>test.py的符号名集合和常量集合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">co.co_names   (‘s’, ’func’)</div><div class="line">co.co_consts  (‘hello’, &lt;code object func at 0x2aaeeec57110, file ”test.py”, line 3&gt;, None)</div></pre></td></tr></table></figure>
<p>如果你想查看当前栈帧，Python提供了<code>sys._getframe()</code>方法可以获取当前栈帧，你只需要在代码里加入代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">import</span> sys</div><div class="line">    frame = sys._getframe()</div><div class="line">    <span class="keyword">print</span> frame.f_locals</div><div class="line">    <span class="keyword">print</span> frame.f_globals</div><div class="line">    <span class="keyword">print</span> frame.f_back.f_locals</div><div class="line">    <span class="comment">#你可以打印frame的各个域</span></div><div class="line">    <span class="keyword">print</span> s</div></pre></td></tr></table></figure>
<h2 id="Python-黑魔法"><a href="#Python-黑魔法" class="headerlink" title="Python 黑魔法"></a>Python 黑魔法</h2><h3 id="Python-多继承"><a href="#Python-多继承" class="headerlink" title="Python 多继承"></a>Python 多继承</h3><figure class="highlight"><table><tr><td class="code"><pre><div class="line">In [1]: class A(object):</div><div class="line">   ...:         def foo(self):</div><div class="line">   ...:                 print("class A")</div><div class="line">   ...:</div><div class="line"></div><div class="line">In [2]: class B(object):</div><div class="line">   ...:         def foo(self):</div><div class="line">   ...:                 print("class B")</div><div class="line">   ...:</div><div class="line"></div><div class="line">In [3]: class C(A, B):</div><div class="line">   ...:         pass</div><div class="line">   ...:</div><div class="line"></div><div class="line">In [4]: C().foo()</div><div class="line">class A # 例子很好懂, C继承了A和B，从左到右,发现A有foo方法,返回了</div></pre></td></tr></table></figure>
<p>看起来都是很简单, 有次序的从底向上,从前向后找,找到就返回. 再看例子:</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">In [5]: class A(object):</div><div class="line">   ...:        def foo(self):</div><div class="line">   ...:               print("class A")</div><div class="line">   ...:</div><div class="line"></div><div class="line">In [6]: class B(A):</div><div class="line">   ...:        pass</div><div class="line">   ...:</div><div class="line"></div><div class="line">In [7]: class C(A):</div><div class="line">   ...:        def foo(self):</div><div class="line">   ...:               print("class C")</div><div class="line">   ...:</div><div class="line"></div><div class="line">In [8]: class D(B,C):</div><div class="line">   ...:        pass</div><div class="line">   ...:</div><div class="line"></div><div class="line">In [9]: D().foo()</div><div class="line">class C # ? 按道理, 顺序是 D-&gt;B-&gt;A,为什么找到了C哪去了</div></pre></td></tr></table></figure>
<p>这也就涉及了MRO(Method Resolution Order):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">In [<span class="number">10</span>]: D.__mro__</div><div class="line">Out[<span class="number">10</span>]: (__main__.D, __main__.B, __main__.C, __main__.A, object)</div></pre></td></tr></table></figure>
<p>简单的理解其实就是新式类是广度优先了， D-&gt;B, 但是发现C也是继承A，就先找C，最后再去找A</p>
<h3 id="列表的-和-append和extend"><a href="#列表的-和-append和extend" class="headerlink" title="列表的+和+=, append和extend"></a>列表的+和+=, append和extend</h3><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">In [<span class="number">17</span>]: print(<span class="string">'ID:'</span>, id(a_list))</div><div class="line">(<span class="string">'ID:'</span>, <span class="number">4481323592</span>)</div><div class="line"></div><div class="line">In [<span class="number">18</span>]: a_list += [<span class="number">1</span>]</div><div class="line"></div><div class="line">In [<span class="number">19</span>]: print(<span class="string">'ID (+=):'</span>, id(a_list))</div><div class="line">(<span class="string">'ID (+=):'</span>, <span class="number">4481323592</span>) <span class="comment"># 使用+= 还是在原来的列表上操作</span></div><div class="line"></div><div class="line">In [<span class="number">20</span>]: a_list = a_list + [<span class="number">2</span>]</div><div class="line"></div><div class="line">In [<span class="number">21</span>]: print(<span class="string">'ID (list = list + ...):'</span>, id(a_list))</div><div class="line">(<span class="string">'ID (list = list + ...):'</span>, <span class="number">4481293056</span>) <span class="comment"># 简单的+其实已经改变了原有列表</span></div><div class="line">In [<span class="number">28</span>]: a_list = []</div><div class="line"></div><div class="line">In [<span class="number">29</span>]: id(a_list)</div><div class="line">Out[<span class="number">29</span>]: <span class="number">4481326976</span></div><div class="line"></div><div class="line">In [<span class="number">30</span>]: a_list.append(<span class="number">1</span>)</div><div class="line"></div><div class="line">In [<span class="number">31</span>]: id(a_list)</div><div class="line">Out[<span class="number">31</span>]: <span class="number">4481326976</span> <span class="comment"># append 是在原有列表添加</span></div><div class="line"></div><div class="line">In [<span class="number">32</span>]: a_list.extend([<span class="number">2</span>])</div><div class="line"></div><div class="line">In [<span class="number">33</span>]: id(a_list)</div><div class="line">Out[<span class="number">33</span>]: <span class="number">4481326976</span> <span class="comment"># extend 也是在原有列表上添加</span></div></pre></td></tr></table></figure>
<h3 id="datetime也有布尔值"><a href="#datetime也有布尔值" class="headerlink" title="datetime也有布尔值"></a>datetime也有布尔值</h3><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">In [<span class="number">34</span>]: <span class="keyword">import</span> datetime</div><div class="line"></div><div class="line">In [<span class="number">35</span>]: print(<span class="string">'"datetime.time(0,0,0)" (Midnight) -&gt;'</span>, bool(datetime.time(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)))</div><div class="line">(<span class="string">'"datetime.time(0,0,0)" (Midnight) -&gt;'</span>, <span class="keyword">False</span>)</div><div class="line"></div><div class="line">In [<span class="number">36</span>]: print(<span class="string">'"datetime.time(1,0,0)" (1 am) -&gt;'</span>, bool(datetime.time(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)))</div><div class="line">(<span class="string">'"datetime.time(1,0,0)" (1 am) -&gt;'</span>, <span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<h3 id="’-’-和-is-的区别"><a href="#’-’-和-is-的区别" class="headerlink" title="’==’ 和 is 的区别"></a>’==’ 和 is 的区别</h3><p>我的理解是”is”是判断2个对象的身份, ==是判断2个对象的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">In [<span class="number">37</span>]: a = <span class="number">1</span></div><div class="line"></div><div class="line">In [<span class="number">38</span>]: b = <span class="number">1</span></div><div class="line"></div><div class="line">In [<span class="number">39</span>]: print(<span class="string">'a is b'</span>, bool(a <span class="keyword">is</span> b))</div><div class="line">(<span class="string">'a is b'</span>, <span class="keyword">True</span>)</div><div class="line"></div><div class="line">In [<span class="number">40</span>]: c = <span class="number">999</span></div><div class="line"></div><div class="line">In [<span class="number">41</span>]: d = <span class="number">999</span></div><div class="line"></div><div class="line">In [<span class="number">42</span>]: print(<span class="string">'c is d'</span>, bool(c <span class="keyword">is</span> d))</div><div class="line">(<span class="string">'c is d'</span>, <span class="keyword">False</span>) <span class="comment"># 原因是python的内存管理,缓存了-5 - 256的对象</span></div><div class="line"></div><div class="line">In [<span class="number">43</span>]: print(<span class="string">'256 is 257-1'</span>, <span class="number">256</span> <span class="keyword">is</span> <span class="number">257</span><span class="number">-1</span>)</div><div class="line">(<span class="string">'256 is 257-1'</span>, <span class="keyword">True</span>)</div><div class="line"></div><div class="line">In [<span class="number">44</span>]: print(<span class="string">'257 is 258-1'</span>, <span class="number">257</span> <span class="keyword">is</span> <span class="number">258</span> - <span class="number">1</span>)</div><div class="line">(<span class="string">'257 is 258-1'</span>, <span class="keyword">False</span>)</div><div class="line"></div><div class="line">In [<span class="number">45</span>]: print(<span class="string">'-5 is -6+1'</span>, <span class="number">-5</span> <span class="keyword">is</span> <span class="number">-6</span>+<span class="number">1</span>)</div><div class="line">(<span class="string">'-5 is -6+1'</span>, <span class="keyword">True</span>)</div><div class="line"></div><div class="line">In [<span class="number">46</span>]: print(<span class="string">'-7 is -6-1'</span>, <span class="number">-7</span> <span class="keyword">is</span> <span class="number">-6</span><span class="number">-1</span>)</div><div class="line">(<span class="string">'-7 is -6-1'</span>, <span class="keyword">False</span>)</div><div class="line">In [<span class="number">47</span>]: a = <span class="string">'hello world!'</span></div><div class="line"></div><div class="line">In [<span class="number">48</span>]: b = <span class="string">'hello world!'</span></div><div class="line"></div><div class="line">In [<span class="number">49</span>]: print(<span class="string">'a is b,'</span>, a <span class="keyword">is</span> b)</div><div class="line">(<span class="string">'a is b,'</span>, <span class="keyword">False</span>) <span class="comment"># 很明显 他们没有被缓存,这是2个字段串的对象</span></div><div class="line"></div><div class="line">In [<span class="number">50</span>]: print(<span class="string">'a == b,'</span>, a == b)</div><div class="line">(<span class="string">'a == b,'</span>, <span class="keyword">True</span>) <span class="comment"># 但他们的值相同</span></div><div class="line"><span class="comment"># But, 有个特例</span></div><div class="line">In [<span class="number">51</span>]: a = float(<span class="string">'nan'</span>)</div><div class="line"></div><div class="line">In [<span class="number">52</span>]: print(<span class="string">'a is a,'</span>, a <span class="keyword">is</span> a)</div><div class="line">(<span class="string">'a is a,'</span>, <span class="keyword">True</span>)</div><div class="line"></div><div class="line">In [<span class="number">53</span>]: print(<span class="string">'a == a,'</span>, a == a)</div><div class="line">(<span class="string">'a == a,'</span>, <span class="keyword">False</span>) <span class="comment"># 亮瞎我眼睛了~</span></div></pre></td></tr></table></figure>
<h3 id="bool其实是int的子类"><a href="#bool其实是int的子类" class="headerlink" title="bool其实是int的子类"></a>bool其实是int的子类</h3><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">In [<span class="number">97</span>]: isinstance(<span class="keyword">True</span>, int)</div><div class="line">Out[<span class="number">97</span>]: <span class="keyword">True</span></div><div class="line"></div><div class="line">In [<span class="number">98</span>]: <span class="keyword">True</span> + <span class="keyword">True</span></div><div class="line">Out[<span class="number">98</span>]: <span class="number">2</span></div><div class="line"></div><div class="line">In [<span class="number">99</span>]: <span class="number">3</span> * <span class="keyword">True</span> + <span class="keyword">True</span></div><div class="line">Out[<span class="number">99</span>]: <span class="number">4</span></div><div class="line"></div><div class="line">In [<span class="number">100</span>]: <span class="number">3</span> * <span class="keyword">True</span> - <span class="keyword">False</span></div><div class="line">Out[<span class="number">100</span>]: <span class="number">3</span></div><div class="line"></div><div class="line">In [<span class="number">104</span>]: <span class="keyword">True</span> &lt;&lt; <span class="number">10</span></div><div class="line">Out[<span class="number">104</span>]: <span class="number">1024</span></div></pre></td></tr></table></figure>
<h3 id="元组是不是真的不可变"><a href="#元组是不是真的不可变" class="headerlink" title="元组是不是真的不可变?"></a>元组是不是真的不可变?</h3><figure class="highlight"><table><tr><td class="code"><pre><div class="line">In [111]: tup = ([],)</div><div class="line"></div><div class="line">In [112]: tup[0] += [1]</div><div class="line">---------------------------------------------------------------------------</div><div class="line">TypeError                                 Traceback (most recent call last)</div><div class="line">&lt;ipython-input-112-d4f292cf35de&gt; in &lt;module&gt;()</div><div class="line">----&gt; 1 tup[0] += [1]</div><div class="line"></div><div class="line">TypeError: 'tuple' object does not support item assignment</div><div class="line"></div><div class="line">In [113]: tup</div><div class="line">Out[113]: ([1],) # 我靠 又是亮瞎我眼睛,明明抛了异常 还能修改?</div><div class="line"></div><div class="line">In [114]: tup = ([],)</div><div class="line"></div><div class="line">In [115]: tup[0].extend([1])</div><div class="line"></div><div class="line">In [116]: tup[0]</div><div class="line">Out[116]: [1] # 好吧,我有点看明白了, 虽然我不能直接操作元组，但是不能阻止我操作元组中可变的子对象(list)</div></pre></td></tr></table></figure>
<p>+= 是一个特例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">In [<span class="number">117</span>]: my_tup = (<span class="number">1</span>,)</div><div class="line"></div><div class="line">In [<span class="number">118</span>]: my_tup += (<span class="number">4</span>,)</div><div class="line"></div><div class="line">In [<span class="number">119</span>]: my_tup = my_tup + (<span class="number">5</span>,)</div><div class="line"></div><div class="line">In [<span class="number">120</span>]: my_tup</div><div class="line">Out[<span class="number">120</span>]: (<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment"># ? 嗯 不是不能操作元组嘛?</span></div><div class="line"></div><div class="line">In [<span class="number">121</span>]: my_tup = (<span class="number">1</span>,)</div><div class="line"></div><div class="line">In [<span class="number">122</span>]: print(id(my_tup))</div><div class="line"><span class="number">4481317904</span></div><div class="line"></div><div class="line">In [<span class="number">123</span>]: my_tup += (<span class="number">4</span>,)</div><div class="line"></div><div class="line">In [<span class="number">124</span>]: print(id(my_tup))</div><div class="line"><span class="number">4480606864</span> <span class="comment"># 操作的不是原来的元组 所以可以</span></div><div class="line"></div><div class="line">In [<span class="number">125</span>]: my_tup = my_tup + (<span class="number">5</span>,)</div><div class="line"></div><div class="line">In [<span class="number">126</span>]: print(id(my_tup))</div><div class="line"><span class="number">4474234912</span></div></pre></td></tr></table></figure>
<h3 id="异常处理加-else"><a href="#异常处理加-else" class="headerlink" title="异常处理加 else"></a>异常处理加 else</h3><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">In [<span class="number">150</span>]: <span class="keyword">try</span>:</div><div class="line">   .....:     print(<span class="string">'third element:'</span>, a_list[<span class="number">2</span>])</div><div class="line">   .....: <span class="keyword">except</span> IndexError:</div><div class="line">   .....:     print(<span class="string">'raised IndexError'</span>)</div><div class="line">   .....: <span class="keyword">else</span>:</div><div class="line">   .....:     print(<span class="string">'no error in try-block'</span>) <span class="comment"># 只有在try里面没有异常的时候才会执行else里面的表达式</span></div><div class="line">   .....:</div><div class="line">raised IndexError <span class="comment"># 抛异常了 没完全完成</span></div><div class="line">In [<span class="number">153</span>]: i = <span class="number">0</span></div><div class="line"></div><div class="line">In [<span class="number">154</span>]: <span class="keyword">while</span> i &lt; <span class="number">2</span>:</div><div class="line">   .....:     print(i)</div><div class="line">   .....:     i += <span class="number">1</span></div><div class="line">   .....: <span class="keyword">else</span>:</div><div class="line">   .....:     print(<span class="string">'in else'</span>)</div><div class="line">   .....:</div><div class="line"><span class="number">0</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="keyword">in</span> <span class="keyword">else</span> <span class="comment"># while也支持哦~</span></div><div class="line">In [<span class="number">155</span>]: i = <span class="number">0</span></div><div class="line"></div><div class="line">In [<span class="number">156</span>]: <span class="keyword">while</span> i &lt; <span class="number">2</span>:</div><div class="line">   .....:         print(i)</div><div class="line">   .....:         i += <span class="number">1</span></div><div class="line">   .....:         <span class="keyword">break</span></div><div class="line">   .....: <span class="keyword">else</span>:</div><div class="line">   .....:         print(<span class="string">'completed while-loop'</span>)</div><div class="line">   .....:</div><div class="line"><span class="number">0</span> <span class="comment"># 被break了 没有完全执行完 就不执行else里面的了</span></div><div class="line">In [<span class="number">158</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</div><div class="line">   .....:         print(i)</div><div class="line">   .....: <span class="keyword">else</span>:</div><div class="line">   .....:         print(<span class="string">'completed for-loop'</span>)</div><div class="line">   .....:</div><div class="line"><span class="number">0</span></div><div class="line"><span class="number">1</span></div><div class="line">completed <span class="keyword">for</span>-loop</div><div class="line"></div><div class="line">In [<span class="number">159</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</div><div class="line">   .....:         print(i)</div><div class="line">   .....:         <span class="keyword">break</span></div><div class="line">   .....: <span class="keyword">else</span>:</div><div class="line">   .....:         print(<span class="string">'completed for-loop'</span>)</div><div class="line">   .....:</div><div class="line"><span class="number">0</span> <span class="comment"># 也是因为break了</span></div></pre></td></tr></table></figure>
<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><h3 id="对象赋值"><a href="#对象赋值" class="headerlink" title="对象赋值"></a>对象赋值</h3><p>Python中，对象的赋值，拷贝（深/浅拷贝）之间是有差异的，如果使用的时候不注意，就可能产生意外的结果。</p>
<p>直接看一段代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">will = [<span class="string">"Will"</span>, <span class="number">28</span>, [<span class="string">"Python"</span>, <span class="string">"C#"</span>, <span class="string">"JavaScript"</span>]]</div><div class="line">wilber = will</div><div class="line"><span class="keyword">print</span> id(will)</div><div class="line"><span class="keyword">print</span> will</div><div class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</div><div class="line"><span class="keyword">print</span> id(wilber)</div><div class="line"><span class="keyword">print</span> wilber</div><div class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</div><div class="line"></div><div class="line">will[<span class="number">0</span>] = <span class="string">"Wilber"</span></div><div class="line">will[<span class="number">2</span>].append(<span class="string">"CSS"</span>)</div><div class="line"><span class="keyword">print</span> id(will)</div><div class="line"><span class="keyword">print</span> will</div><div class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</div><div class="line"><span class="keyword">print</span> id(wilber)</div><div class="line"><span class="keyword">print</span> wilber</div><div class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</div></pre></td></tr></table></figure>
<p><img src="media/14521096832549/tip1.png" alt="tip1"></p>
<p>下面来分析一下这段代码：</p>
<ul>
<li>首先，创建了一个名为will的变量，这个变量指向一个list对象，从第一张图中可以看到所有对象的地址（每次运行，结果可能不同）</li>
<li>然后，通过will变量对wilber变量进行赋值，那么wilber变量将指向will变量对应的对象（内存地址），也就是说”wilber is will”，”wilber[i] is will[i]”</li>
<li>可以理解为，Python中，对象的赋值都是进行对象引用（内存地址）传递</li>
</ul>
<p>第三张图中，由于will和wilber指向同一个对象，所以对will的任何修改都会体现在wilber上<br>这里需要注意的一点是，str是不可变类型，所以当修改的时候会替换旧的对象，产生一个新的地址39758496</p>
<p><img src="/images/14588487955418.jpg" alt=""></p>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>下面就来看看浅拷贝的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> copy</div><div class="line"></div><div class="line">will = [<span class="string">"Will"</span>, <span class="number">28</span>, [<span class="string">"Python"</span>, <span class="string">"C#"</span>, <span class="string">"JavaScript"</span>]]</div><div class="line">wilber = copy.copy(will)</div><div class="line"></div><div class="line"><span class="keyword">print</span> id(will)</div><div class="line"><span class="keyword">print</span> will</div><div class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</div><div class="line"><span class="keyword">print</span> id(wilber)</div><div class="line"><span class="keyword">print</span> wilber</div><div class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</div><div class="line"></div><div class="line">will[<span class="number">0</span>] = <span class="string">"Wilber"</span></div><div class="line">will[<span class="number">2</span>].append(<span class="string">"CSS"</span>)</div><div class="line"><span class="keyword">print</span> id(will)</div><div class="line"><span class="keyword">print</span> will</div><div class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</div><div class="line"><span class="keyword">print</span> id(wilber)</div><div class="line"><span class="keyword">print</span> wilber</div><div class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</div></pre></td></tr></table></figure>
<p>代码结果为：</p>
<p><img src="/images/14588488054814.jpg" alt=""></p>
<p>分析一下这段代码：</p>
<ul>
<li>首先，依然使用一个will变量，指向一个list类型的对象</li>
<li>然后，通过copy模块里面的浅拷贝函数copy()，对will指向的对象进行浅拷贝，然后浅拷贝生成的新对象赋值给wilber变量<ul>
<li>浅拷贝会创建一个新的对象，这个例子中”wilber is not will”</li>
<li>但是，对于对象中的元素，浅拷贝就只会使用原始元素的引用（内存地址），也就是说”wilber[i] is will[i]”</li>
</ul>
</li>
<li>当对will进行修改的时候<ul>
<li>由于list的第一个元素是不可变类型，所以will对应的list的第一个元素会使用一个新的对象39758496</li>
<li>但是list的第三个元素是一个可变类型，修改操作不会产生新的对象，所以will的修改结果会相应的反应到wilber上</li>
</ul>
</li>
</ul>
<p><img src="/images/14588488145630.jpg" alt=""></p>
<p>总结一下，当我们使用下面的操作的时候，会产生浅拷贝的效果：</p>
<ul>
<li>使用切片[:]操作</li>
<li>使用工厂函数（如list/dir/set）</li>
<li>使用copy模块中的copy()函数</li>
</ul>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>最后来看看深拷贝：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> copy</div><div class="line"></div><div class="line">will = [<span class="string">"Will"</span>, <span class="number">28</span>, [<span class="string">"Python"</span>, <span class="string">"C#"</span>, <span class="string">"JavaScript"</span>]]</div><div class="line">wilber = copy.deepcopy(will)</div><div class="line"></div><div class="line"><span class="keyword">print</span> id(will)</div><div class="line"><span class="keyword">print</span> will</div><div class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</div><div class="line"><span class="keyword">print</span> id(wilber)</div><div class="line"><span class="keyword">print</span> wilber</div><div class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</div><div class="line"></div><div class="line">will[<span class="number">0</span>] = <span class="string">"Wilber"</span></div><div class="line">will[<span class="number">2</span>].append(<span class="string">"CSS"</span>)</div><div class="line"><span class="keyword">print</span> id(will)</div><div class="line"><span class="keyword">print</span> will</div><div class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> will]</div><div class="line"><span class="keyword">print</span> id(wilber)</div><div class="line"><span class="keyword">print</span> wilber</div><div class="line"><span class="keyword">print</span> [id(ele) <span class="keyword">for</span> ele <span class="keyword">in</span> wilber]</div></pre></td></tr></table></figure>
<p>代码的结果为：</p>
<p><img src="/images/14588488380987.jpg" alt=""></p>
<p>分析一下这段代码：</p>
<ul>
<li>首先，同样使用一个will变量，指向一个list类型的对象</li>
<li>然后，通过copy模块里面的深拷贝函数deepcopy()，对will指向的对象进行深拷贝，然后深拷贝生成的新对象赋值给wilber变量<ul>
<li>跟浅拷贝类似，深拷贝也会创建一个新的对象，这个例子中”wilber is not will”</li>
<li>但是，对于对象中的元素，深拷贝都会重新生成一份（有特殊情况，下面会说明），而不是简单的使用原始元素的引用（内存地址）</li>
<li>例子中will的第三个元素指向39737304，而wilber的第三个元素是一个全新的对象39773088，也就是说，”wilber[2] is not will[2]”</li>
</ul>
</li>
<li>当对will进行修改的时候<ul>
<li>由于list的第一个元素是不可变类型，所以will对应的list的第一个元素会使用一个新的对象39758496</li>
<li>但是list的第三个元素是一个可变类型，修改操作不会产生新的对象，但是由于”wilber[2] is not will[2]”，所以will的修改不会影响wilber</li>
</ul>
</li>
</ul>
<p><img src="/images/14588488493152.jpg" alt=""></p>
<h3 id="拷贝的特殊情况"><a href="#拷贝的特殊情况" class="headerlink" title="拷贝的特殊情况"></a>拷贝的特殊情况</h3><p>其实，对于拷贝有一些特殊情况：</p>
<ul>
<li>对于非容器类型（如数字、字符串、和其他’原子’类型的对象）没有拷贝这一说<ul>
<li>也就是说，对于这些类型，”obj is copy.copy(obj)” 、”obj is copy.deepcopy(obj)”</li>
</ul>
</li>
<li>如果元组变量只包含原子类型对象，则不能深拷贝，看下面的例子</li>
</ul>
<p><img src="/images/14588488582446.jpg" alt=""></p>
<p>总结</p>
<p>本文介绍了对象的赋值和拷贝，以及它们之间的差异：</p>
<ul>
<li>Python中对象的赋值都是进行对象引用（内存地址）传递</li>
<li>使用copy.copy()，可以进行对象的浅拷贝，它复制了对象，但对于对象中的元素，依然使用原始的引用.</li>
<li>如果需要复制一个容器对象，以及它里面的所有元素（包含元素的子元素），可以使用copy.deepcopy()进行深拷贝</li>
<li>对于非容器类型（如数字、字符串、和其他’原子’类型的对象）没有被拷贝一说</li>
<li>如果元组变量只包含原子类型对象，则不能深拷贝，看下面的例子</li>
</ul>
<h2 id="Python-中-self-的含义"><a href="#Python-中-self-的含义" class="headerlink" title="Python 中 self 的含义"></a>Python 中 self 的含义</h2><p>刚开始学习Python的类写法的时候觉得很是麻烦，为什么定义时需要而调用时又不需要，为什么不能内部简化从而减少我们敲击键盘的次数？</p>
<h3 id="self代表类的实例，而非类。"><a href="#self代表类的实例，而非类。" class="headerlink" title="self代表类的实例，而非类。"></a>self代表类的实例，而非类。</h3><p>实例来说明</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(self)</span>:</span></div><div class="line">        print(self)</div><div class="line">        print(self.__class__)</div><div class="line"></div><div class="line">t = Test()</div><div class="line">t.prt()</div></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">&lt;__main__.Test object at <span class="number">0x000000000284E080</span>&gt;</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Test</span>'&gt;</span></div></pre></td></tr></table></figure>
<p>从上面的例子中可以很明显的看出，self代表的是类的实例。而self.class则指向类。</p>
<h3 id="self不必非写成self"><a href="#self不必非写成self" class="headerlink" title="self不必非写成self"></a>self不必非写成self</h3><p>有很多童鞋是先学习别的语言然后学习Python的，所以总觉得self怪怪的，想写成this，可以吗？</p>
<p>当然可以，还是把上面的代码改写一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(this)</span>:</span></div><div class="line">        print(this)</div><div class="line">        print(this.__class__)</div><div class="line"></div><div class="line">t = Test()</div><div class="line">t.prt()</div></pre></td></tr></table></figure>
<p>改成this后，运行结果完全一样。</p>
<p>当然，最好还是尊重约定俗成的习惯，使用self。</p>
<h3 id="self可以不写吗"><a href="#self可以不写吗" class="headerlink" title="self可以不写吗"></a>self可以不写吗</h3><p>在Python的解释器内部，当我们调用t.prt()时，实际上Python解释成Test.prt(t)，也就是说把self替换成类的实例。</p>
<p>有兴趣的童鞋可以把上面的t.prt()一行改写一下，运行后的实际结果完全相同。</p>
<p>实际上已经部分说明了self在定义时不可以省略，如果非要试一下，那么请看下面：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">()</span>:</span></div><div class="line">        print(self)</div><div class="line"></div><div class="line">t = Test()</div><div class="line">t.prt()</div></pre></td></tr></table></figure>
<p>运行时提醒错误如下：prt在定义时没有参数，但是我们运行时强行传了一个参数。<br>由于上面解释过了t.prt()等同于Test.prt(t)，所以程序提醒我们多传了一个参数t。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;h.py&quot;, line 6, in &lt;module&gt;</div><div class="line">    t.prt()</div><div class="line">TypeError: prt() takes 0 positional arguments but 1 was given</div></pre></td></tr></table></figure>
<p>当然，如果我们的定义和调用时均不传类实例是可以的，这就是类方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">()</span>:</span></div><div class="line">        print(__class__)</div><div class="line">Test.prt()</div></pre></td></tr></table></figure>
<p>运行结果如下</p>
<pre><code>&lt;class &apos;__main__.Test&apos;&gt;
</code></pre><p>在继承时，传入的是哪个实例，就是那个传入的实例，而不是指定义了self的类的实例。<br>先看代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pprt</span><span class="params">(self)</span>:</span></div><div class="line">        print(self)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Parent)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cprt</span><span class="params">(self)</span>:</span></div><div class="line">        print(self)</div><div class="line">c = Child()</div><div class="line">c.cprt()</div><div class="line">c.pprt()</div><div class="line">p = Parent()</div><div class="line">p.pprt()</div></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;__main__.Child object at 0x0000000002A47080&gt;</div><div class="line">&lt;__main__.Child object at 0x0000000002A47080&gt;</div><div class="line">&lt;__main__.Parent object at 0x0000000002A47240&gt;</div></pre></td></tr></table></figure>
<p>解释：</p>
<p>运行c.cprt()时应该没有理解问题，指的是Child类的实例。</p>
<p>但是在运行c.pprt()时，等同于Child.pprt(c)，所以self指的依然是Child类的实例，由于self中没有定义pprt()方法，所以沿着继承树往上找，发现在父类Parent中定义了pprt()方法，所以就会成功调用。</p>
<p>在描述符类中，self指的是描述符类的实例</p>
<p>不太容易理解，先看实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Desc</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, ins, cls)</span>:</span></div><div class="line">        print(<span class="string">'self in Desc: %s '</span> % self )</div><div class="line">        print(self, ins, cls)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></div><div class="line">    x = Desc()</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'self in Test: %s'</span> % self)</div><div class="line">t = Test()</div><div class="line">t.prt()</div><div class="line">t.x</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">self in Test: &lt;__main__.Test object at 0x0000000002A570B8&gt;</div><div class="line">self in Desc: &lt;__main__.Desc object at 0x000000000283E208&gt;</div><div class="line">&lt;__main__.Desc object at 0x000000000283E208&gt; &lt;__main__.Test object at 0x0000000002A570B8&gt; &lt;class &apos;__main__.Test&apos;&gt;</div></pre></td></tr></table></figure>
<p>大部分童鞋开始有疑问了，为什么在Desc类中定义的self不是应该是调用它的实例t吗？怎么变成了Desc类的实例了呢？</p>
<p>注意：此处需要睁大眼睛看清楚了，这里调用的是t.x，也就是说是Test类的实例t的属性x，由于实例t中并没有定义属性x，所以找到了类属性x，而该属性是描述符属性，为Desc类的实例而已，所以此处并没有顶用Test的任何方法。</p>
<p>那么我们如果直接通过类来调用属性x也可以得到相同的结果。</p>
<p>下面是把t.x改为Test.x运行的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">self in Test: &lt;__main__.Test object at 0x00000000022570B8&gt;</div><div class="line">self in Desc: &lt;__main__.Desc object at 0x000000000223E208&gt;</div><div class="line">&lt;__main__.Desc object at 0x000000000223E208&gt; None &lt;class &apos;__main__.Test&apos;&gt;</div></pre></td></tr></table></figure>
<p>题外话：由于在很多时候描述符类中仍然需要知道调用该描述符的实例是谁，所以在描述符类中存在第二个参数ins，用来表示调用它的类实例，所以t.x时可以看到第三行中的运行结果中第二项为<main.test object="" at="" 0x0000000002a570b8="">。而采用Test.x进行调用时，由于没有实例，所以返回None。</main.test></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>self在定义时需要定义，但是在调用时会自动传入。</li>
<li>self的名字并不是规定死的，但是最好还是按照约定是用self</li>
<li>self总是指调用时的类的实例。</li>
</ul>
<h2 id="Python的内存管理"><a href="#Python的内存管理" class="headerlink" title="Python的内存管理"></a>Python的内存管理</h2><p>以Python语言为例子，说明一门动态类型的、面向对象的语言的内存管理方式。</p>
<h3 id="对象的内存使用"><a href="#对象的内存使用" class="headerlink" title="对象的内存使用"></a>对象的内存使用</h3><p>赋值语句是语言最常见的功能了。但即使是最简单的赋值语句，也可以很有内涵。Python的赋值语句就很值得研究。</p>
<pre><code>a = 1
</code></pre><p>整数1为一个对象。而a是一个引用。利用赋值语句，引用a指向对象1。Python是动态类型的语言(参考动态类型)，对象与引用分离。Python像使用“筷子”那样，通过引用来接触和翻动真正的食物——对象。</p>
<p>为了探索对象在内存的存储，我们可以求助于Python的内置函数id()。它用于返回对象的身份(identity)。其实，这里所谓的身份，就是该对象的内存地址。</p>
<pre><code>a = 1
print(id(a))
print(hex(id(a)))
</code></pre><p>在我的计算机上，它们返回的是:</p>
<pre><code>11246696
’0xab9c68′
</code></pre><p>分别为内存地址的十进制和十六进制表示。</p>
<p>在Python中，整数和短小的字符，Python都会缓存这些对象，以便重复使用。当我们创建多个等于1的引用时，实际上是让所有这些引用指向同一个对象。</p>
<pre><code>a = 1
b = 1
print(id(a))
print(id(b))
</code></pre><p>上面程序返回</p>
<pre><code>11246696
11246696
</code></pre><p>可见a和b实际上是指向同一个对象的两个引用。</p>
<p>为了检验两个引用指向同一个对象，我们可以用is关键字。is用于判断两个引用所指的对象是否相同。</p>
<pre><code># True
a = 1
b = 1
print(a is b)

# True
a = &quot;good&quot;
b = &quot;good&quot;
print(a is b)

# False
a = &quot;very good morning&quot;
b = &quot;very good morning&quot;
print(a is b)

# False
a = []
b = []
print(a is b)
</code></pre><p>上面的注释为相应的运行结果。可以看到，由于Python缓存了整数和短字符串，因此每个对象只存有一份。比如，所有整数1的引用都指向同一对象。即使使用赋值语句，也只是创造了新的引用，而不是对象本身。长的字符串和其它对象可以有多个相同的对象，可以使用赋值语句创建出新的对象。</p>
<p>在Python中，每个对象都有存有指向该对象的引用总数，即引用计数(reference count)。</p>
<p>我们可以使用sys包中的getrefcount()，来查看某个对象的引用计数。需要注意的是，当使用某个引用作为参数，传递给getrefcount()时，参数实际上创建了一个临时的引用。因此，getrefcount()所得到的结果，会比期望的多1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</div><div class="line"></div><div class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">print(getrefcount(a))</div><div class="line"></div><div class="line">b = a</div><div class="line">print(getrefcount(b))</div></pre></td></tr></table></figure>
<p>由于上述原因，两个getrefcount将返回2和3，而不是期望的1和2。</p>
<p>Python的一个容器对象(container)，比如表、词典等，可以包含多个对象。实际上，容器对象中包含的并不是元素对象本身，是指向各个元素对象的引用。</p>
<p>我们也可以自定义一个对象，并引用其它对象:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">from_obj</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, to_obj)</span>:</span></div><div class="line">        self.to_obj = to_obj</div><div class="line"></div><div class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">a = from_obj(b)</div><div class="line">print(id(a.to_obj))</div><div class="line">print(id(b))</div></pre></td></tr></table></figure>
<p>可以看到，a引用了对象b。</p>
<p>对象引用对象，是Python最基本的构成方式。即使是a = 1这一赋值方式，实际上是让词典的一个键值”a”的元素引用整数对象1。该词典对象用于记录所有的全局引用。该词典引用了整数对象1。我们可以通过内置函数globals()来查看该词典。</p>
<p>当一个对象A被另一个对象B引用时，A的引用计数将增加1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</div><div class="line"></div><div class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">print(getrefcount(a))</div><div class="line"></div><div class="line">b = [a, a]</div><div class="line">print(getrefcount(a))</div></pre></td></tr></table></figure>
<p>由于对象b引用了两次a，a的引用计数增加了2。</p>
<p>容器对象的引用可能构成很复杂的拓扑结构。我们可以用objgraph包来绘制其引用关系，比如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">y = [x, dict(key1=x)]</div><div class="line">z = [y, (x, y)]</div><div class="line"></div><div class="line"><span class="keyword">import</span> objgraph</div><div class="line">objgraph.show_refs([z], filename=<span class="string">'ref_topo.png'</span>)</div></pre></td></tr></table></figure>
<p>objgraph是Python的一个第三方包。安装之前需要安装xdot。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo apt-get install xdot</div><div class="line">sudo pip install objgraph</div></pre></td></tr></table></figure>
<p>两个对象可能相互引用，从而构成所谓的引用环(reference cycle)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">a = []</div><div class="line">b = [a]</div><div class="line">a.append(b)</div></pre></td></tr></table></figure>
<p>即使是一个对象，只需要自己引用自己，也能构成引用环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">a = []</div><div class="line">a.append(a)</div><div class="line">print(getrefcount(a))</div></pre></td></tr></table></figure>
<p>引用环会给垃圾回收机制带来很大的麻烦，我将在后面详细叙述这一点。</p>
<p>某个对象的引用计数可能减少。比如，可以使用del关键字删除某个引用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</div><div class="line"></div><div class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">b = a</div><div class="line">print(getrefcount(b))</div><div class="line"></div><div class="line"><span class="keyword">del</span> a</div><div class="line">print(getrefcount(b))</div></pre></td></tr></table></figure>
<p>del也可以用于删除容器元素中的元素，比如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line"><span class="keyword">del</span> a[<span class="number">0</span>]</div><div class="line">print(a)</div></pre></td></tr></table></figure>
<p>如果某个引用指向对象A，当这个引用被重新定向到某个其他对象B时，对象A的引用计数减少:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getrefcount</div><div class="line"></div><div class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">b = a</div><div class="line">print(getrefcount(b))</div><div class="line"></div><div class="line">a = <span class="number">1</span></div><div class="line">print(getrefcount(b))</div></pre></td></tr></table></figure>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>吃太多，总会变胖，Python也是这样。当Python中的对象越来越多，它们将占据越来越大的内存。不过你不用太担心Python的体形，它会乖巧的在适当的时候“减肥”，启动垃圾回收(garbage collection)，将没用的对象清除。在许多语言中都有垃圾回收机制，比如Java和Ruby。尽管最终目的都是塑造苗条的提醒，但不同语言的减肥方案有很大的差异。</p>
<p>从基本原理上，当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如某个新建对象，它被分配给某个引用，对象的引用计数变为1。如果引用被删除，对象的引用计数为0，那么该对象就可以被垃圾回收。比如下面的表:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="keyword">del</span> a</div></pre></td></tr></table></figure>
<p>del a后，已经没有任何引用指向之前建立的[1, 2, 3]这个表。用户不可能通过任何方式接触或者动用这个对象。这个对象如果继续待在内存里，就成了不健康的脂肪。当垃圾回收启动时，Python扫描到这个引用计数为0的对象，就将它所占据的内存清空。</p>
<p>然而，减肥是个昂贵而费力的事情。垃圾回收时，Python不能进行其它的任务。频繁的垃圾回收将大大降低Python的工作效率。如果内存中的对象不多，就没有必要总启动垃圾回收。所以，Python只会在特定条件下，自动启动垃圾回收。当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动。</p>
<p>我们可以通过gc模块的get_threshold()方法，查看该阈值:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> gc</div><div class="line">print(gc.get_threshold())</div></pre></td></tr></table></figure>
<p>返回(700, 10, 10)，后面的两个10是与分代回收相关的阈值，后面可以看到。700即是垃圾回收启动的阈值。可以通过gc中的set_threshold()方法重新设置。</p>
<p>我们也可以手动启动垃圾回收，即使用gc.collect()。</p>
<p>Python同时采用了分代(generation)回收的策略。这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，对于这样一些“长寿”对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率。</p>
<p>小家伙要多检查</p>
<p>Python将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。</p>
<p>这两个次数即上面get_threshold()返回的(700, 10, 10)返回的两个10。也就是说，每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收。</p>
<p>同样可以用set_threshold()来调整，比如对2代对象进行更频繁的扫描。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> gc</div><div class="line">gc.set_threshold(<span class="number">700</span>, <span class="number">10</span>, <span class="number">5</span>)</div></pre></td></tr></table></figure>
<p>引用环的存在会给上面的垃圾回收机制带来很大的困难。这些引用环可能构成无法使用，但引用计数不为0的一些对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">a = []</div><div class="line">b = [a]</div><div class="line">a.append(b)</div><div class="line"></div><div class="line"><span class="keyword">del</span> a</div><div class="line"><span class="keyword">del</span> b</div></pre></td></tr></table></figure>
<p>上面我们先创建了两个表对象，并引用对方，构成一个引用环。删除了a，b引用之后，这两个对象不可能再从程序中调用，就没有什么用处了。但是由于引用环的存在，这两个对象的引用计数都没有降到0，不会被垃圾回收。</p>
<p>为了回收这样的引用环，Python复制每个对象的引用计数，可以记为gc_ref。假设，每个对象i，该计数为gc_ref_i。Python会遍历所有的对象i。对于每个对象i引用的对象j，将相应的gc_ref_j减1。</p>
<p>在结束遍历后，gc_ref不为0的对象，和这些对象引用的对象，以及继续更下游引用的对象，需要被保留。而其它的对象则被垃圾回收。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Python作为一种动态类型的语言，其对象和引用分离。这与曾经的面向过程语言有很大的区别。为了有效的释放内存，Python内置了垃圾回收的支持。Python采取了一种相对简单的垃圾回收机制，即引用计数，并因此需要解决孤立引用环的问题。Python与其它语言既有共通性，又有特别的地方。对该内存管理机制的理解，是提高Python性能的重要一步。</p>
<h2 id="字典推导-Dictionary-comprehensions-和集合推导-Set-comprehensions"><a href="#字典推导-Dictionary-comprehensions-和集合推导-Set-comprehensions" class="headerlink" title="字典推导(Dictionary comprehensions)和集合推导(Set comprehensions)"></a>字典推导(Dictionary comprehensions)和集合推导(Set comprehensions)</h2><p>大多数的Python程序员都知道且使用过列表推导(list comprehensions)。如果你对list comprehensions概念不是很熟悉——一个list comprehension就是一个更简短、简洁的创建一个list的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>some_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>another_list = [ x + <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> some_list ]</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>another_list</div><div class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div></pre></td></tr></table></figure>
<p>自从python 3.1 (甚至是Python 2.7)起，我们可以用同样的语法来创建集合和字典表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Set Comprehensions</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>some_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>]</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>even_set = &#123; x <span class="keyword">for</span> x <span class="keyword">in</span> some_list <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> &#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>even_set</div><div class="line">set([<span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>])</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Dict Comprehensions</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123; x: x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) &#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="number">1</span>: <span class="keyword">False</span>, <span class="number">2</span>: <span class="keyword">True</span>, <span class="number">3</span>: <span class="keyword">False</span>, <span class="number">4</span>: <span class="keyword">True</span>, <span class="number">5</span>: <span class="keyword">False</span>, <span class="number">6</span>: <span class="keyword">True</span>, <span class="number">7</span>: <span class="keyword">False</span>, <span class="number">8</span>: <span class="keyword">True</span>, <span class="number">9</span>: <span class="keyword">False</span>, <span class="number">10</span>: <span class="keyword">True</span>&#125;</div></pre></td></tr></table></figure>
<p>在第一个例子里，我们以some_list为基础，创建了一个具有不重复元素的集合，而且集合里只包含偶数。而在字典表的例子里，我们创建了一个key是不重复的1到10之间的整数，value是布尔型，用来指示key是否是偶数。</p>
<p>这里另外一个值得注意的事情是集合的字面量表示法。我们可以简单的用这种方法创建一个集合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_set</div><div class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</div></pre></td></tr></table></figure>
<p>而不需要使用内置函数set()。</p>
<h2 id="Python调用系统命令或者脚本"><a href="#Python调用系统命令或者脚本" class="headerlink" title="Python调用系统命令或者脚本"></a>Python调用系统命令或者脚本</h2><p>使用 os.system() 调用系统命令 , 程序中无法获得到输出和返回值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.system(<span class="string">'ls -l /proc/cpuinfo'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.system(<span class="string">"ls -l /proc/cpuinfo"</span>)</div><div class="line">  -r--r--r-- <span class="number">1</span> root root <span class="number">0</span>  <span class="number">3</span>月 <span class="number">29</span> <span class="number">16</span>:<span class="number">53</span> /proc/cpuinfo</div><div class="line">  <span class="number">0</span></div></pre></td></tr></table></figure>
<p>使用 os.popen() 调用系统命令, 程序中可以获得命令输出，但是不能得到执行的返回值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>out = os.popen(<span class="string">"ls -l /proc/cpuinfo"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> out.read()</div><div class="line">  -r--r--r-- <span class="number">1</span> root root <span class="number">0</span>  <span class="number">3</span>月 <span class="number">29</span> <span class="number">16</span>:<span class="number">59</span> /proc/cpuinfo</div></pre></td></tr></table></figure>
<p>使用 commands.getstatusoutput() 调用系统命令, 程序中可以获得命令输出和执行的返回值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> commands</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>commands.getstatusoutput(<span class="string">'ls /bin/ls'</span>)</div><div class="line">  (<span class="number">0</span>, <span class="string">'/bin/ls'</span>)</div></pre></td></tr></table></figure>
<h2 id="Python-捕获用户-Ctrl-C-Ctrl-D-事件"><a href="#Python-捕获用户-Ctrl-C-Ctrl-D-事件" class="headerlink" title="Python 捕获用户 Ctrl+C ,Ctrl+D 事件"></a>Python 捕获用户 Ctrl+C ,Ctrl+D 事件</h2><p>有些时候，需要在程序中捕获用户键盘事件，比如ctrl+c退出，这样可以更好的安全退出程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    do_some_func()</div><div class="line"><span class="keyword">except</span> KeyboardInterrupt:</div><div class="line">    <span class="keyword">print</span> <span class="string">"User Press Ctrl+C,Exit"</span></div><div class="line"><span class="keyword">except</span> EOFError:</div><div class="line">    <span class="keyword">print</span> <span class="string">"User Press Ctrl+D,Exit"</span></div></pre></td></tr></table></figure>
<h2 id="Python-读写文件"><a href="#Python-读写文件" class="headerlink" title="Python 读写文件"></a>Python 读写文件</h2><p>一次性读入文件到列表，速度较快，适用文件比较小的情况下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">track_file = <span class="string">"track_stock.conf"</span></div><div class="line">fd = open(track_file)</div><div class="line">content_list = fd.readlines()</div><div class="line">fd.close()</div><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> content_list:</div><div class="line">    <span class="keyword">print</span> line</div></pre></td></tr></table></figure>
<p>逐行读入，速度较慢,适用没有足够内存读取整个文件(文件太大)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">fd = open(file_path)</div><div class="line">fd.seek(<span class="number">0</span>)</div><div class="line">title = fd.readline()</div><div class="line">keyword = fd.readline()</div><div class="line">uuid = fd.readline()</div><div class="line">fd.close()</div></pre></td></tr></table></figure>
<p>写文件 write 与 writelines 的区别   </p>
<ul>
<li>Fd.write(str) : 把str写到文件中，write()并不会在str后加上一个换行符</li>
<li>Fd.writelines(content) : 把content的内容全部写到文件中,原样写入，不会在每行后面加上任何东西</li>
</ul>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器使一个函数或方法包装在另一个函数里头，可以在被包装的函数添加一些额外的功能，比如日志，还可以对参数、返回结果进行修改。装饰器有点类似Java中的AOP。下面这个例子是打印被装饰的函数里面的参数的装饰器，  </p>
<pre><code>&gt;&gt;&gt; def print_args(function):
&gt;&gt;&gt;     def wrapper(*args, **kwargs):
&gt;&gt;&gt;         print &apos;Arguments:&apos;, args, kwargs
&gt;&gt;&gt;         return function(*args, **kwargs)
&gt;&gt;&gt;     return wrapper

&gt;&gt;&gt; @print_args
&gt;&gt;&gt; def write(text):
&gt;&gt;&gt;     print text

&gt;&gt;&gt; write(&apos;foo&apos;)
Arguments: (&apos;foo&apos;,) {}
foo
</code></pre><p>@是语法糖，它等价于：  </p>
<pre><code>&gt;&gt;&gt; write = print_args(write)
&gt;&gt;&gt; write(&apos;foo&apos;)
arguments: (&apos;foo&apos;,) {}
foo
</code></pre>
      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>您的支持是对我创作最大的鼓励！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/misc/wechat.jpg" alt="wdxtub WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/misc/alipay.jpg" alt="wdxtub Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/编程/" rel="tag">#编程</a>
          
            <a href="/tags/Python/" rel="tag">#Python</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/03/24/self-knowledge-management/" rel="next" title="个人知识管理指南">
                <i class="fa fa-chevron-left"></i> 个人知识管理指南
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/03/24/visual-code-guide/" rel="prev" title="VS Code 指南">
                VS Code 指南 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          

  <p>热评文章</p>
  <div class="ds-top-threads" data-range="weekly" data-num-items="4"></div>


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/03/24/thinking-in-python/"
           data-title="Python 编程思想" data-url="http://wdxtub.com/2016/03/24/thinking-in-python/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/misc/avatar.jpg"
               alt="wdxtub" />
          <p class="site-author-name" itemprop="name">wdxtub</p>
          <p class="site-description motion-element" itemprop="description">人文/科学/读书/写作/思考/编程/架构/数据/广交朋友/@SYSU/@CMU</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">710</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">874</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/wdxtub" target="_blank" title="GitHub">
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/wdxtub" target="_blank" title="微博">
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://douban.com/people/wdx" target="_blank" title="豆瓣">
                  
                  豆瓣
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/wdxtub" target="_blank" title="知乎">
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              不妨看看
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://zhchbin.github.io/" title="zhchbin" target="_blank">zhchbin</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.algorithmdog.com/" title="算法狗" target="_blank">算法狗</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.52cs.org/" title="我爱计算机" target="_blank">我爱计算机</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://jackqdyulei.github.io/" title="雷雷" target="_blank">雷雷</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://guojiex.github.io/" title="瓜瓜" target="_blank">瓜瓜</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://wdxtub.lofter.com/" title="我的 Lofter" target="_blank">我的 Lofter</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://wdxtub.com/interview/" title="刷题笔记" target="_blank">刷题笔记</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#浅谈-Python-的-with-语句"><span class="nav-number">1.</span> <span class="nav-text">浅谈 Python 的 with 语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#术语"><span class="nav-number">1.1.</span> <span class="nav-text">术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本语法和工作原理"><span class="nav-number">1.2.</span> <span class="nav-text">基本语法和工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python程序的执行原理"><span class="nav-number">2.</span> <span class="nav-text">Python程序的执行原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分析字节码"><span class="nav-number">2.1.</span> <span class="nav-text">分析字节码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行字节码"><span class="nav-number">2.2.</span> <span class="nav-text">执行字节码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python-黑魔法"><span class="nav-number">3.</span> <span class="nav-text">Python 黑魔法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Python-多继承"><span class="nav-number">3.1.</span> <span class="nav-text">Python 多继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列表的-和-append和extend"><span class="nav-number">3.2.</span> <span class="nav-text">列表的+和+=, append和extend</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#datetime也有布尔值"><span class="nav-number">3.3.</span> <span class="nav-text">datetime也有布尔值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#’-’-和-is-的区别"><span class="nav-number">3.4.</span> <span class="nav-text">’==’ 和 is 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bool其实是int的子类"><span class="nav-number">3.5.</span> <span class="nav-text">bool其实是int的子类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元组是不是真的不可变"><span class="nav-number">3.6.</span> <span class="nav-text">元组是不是真的不可变?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常处理加-else"><span class="nav-number">3.7.</span> <span class="nav-text">异常处理加 else</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深拷贝与浅拷贝"><span class="nav-number">4.</span> <span class="nav-text">深拷贝与浅拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象赋值"><span class="nav-number">4.1.</span> <span class="nav-text">对象赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浅拷贝"><span class="nav-number">4.2.</span> <span class="nav-text">浅拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深拷贝"><span class="nav-number">4.3.</span> <span class="nav-text">深拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拷贝的特殊情况"><span class="nav-number">4.4.</span> <span class="nav-text">拷贝的特殊情况</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python-中-self-的含义"><span class="nav-number">5.</span> <span class="nav-text">Python 中 self 的含义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#self代表类的实例，而非类。"><span class="nav-number">5.1.</span> <span class="nav-text">self代表类的实例，而非类。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#self不必非写成self"><span class="nav-number">5.2.</span> <span class="nav-text">self不必非写成self</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#self可以不写吗"><span class="nav-number">5.3.</span> <span class="nav-text">self可以不写吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">5.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python的内存管理"><span class="nav-number">6.</span> <span class="nav-text">Python的内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的内存使用"><span class="nav-number">6.1.</span> <span class="nav-text">对象的内存使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收"><span class="nav-number">6.2.</span> <span class="nav-text">垃圾回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">6.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字典推导-Dictionary-comprehensions-和集合推导-Set-comprehensions"><span class="nav-number">7.</span> <span class="nav-text">字典推导(Dictionary comprehensions)和集合推导(Set comprehensions)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python调用系统命令或者脚本"><span class="nav-number">8.</span> <span class="nav-text">Python调用系统命令或者脚本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python-捕获用户-Ctrl-C-Ctrl-D-事件"><span class="nav-number">9.</span> <span class="nav-text">Python 捕获用户 Ctrl+C ,Ctrl+D 事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python-读写文件"><span class="nav-number">10.</span> <span class="nav-text">Python 读写文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#装饰器"><span class="nav-number">11.</span> <span class="nav-text">装饰器</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2013 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wdxtub</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"wdxblog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementById('footer')
      || document.getElementById('footer')).appendChild(ds);
    })();
  </script>

  
    
      
      <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
      <script src="/js/src/hook-duoshuo.js"></script>
    
  





  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';                
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });
                            
                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').mousedown(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>

  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src=""></script>


  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


</body>
</html>
