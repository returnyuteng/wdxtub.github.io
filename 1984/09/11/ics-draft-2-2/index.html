<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="计算机,初稿," />





  <link rel="alternate" href="/atom.xml" title="小土刀" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="学习计算机系统的一个难点在于概念本身的交叉关联，这意味着我们很难在『完全』弄懂一个概念之后再学习新的概念，而是需要一直带着疑问进行学习和探索，直到把知识融会贯通。在了解完编码之后，就可以把编程语言作为理解计算机系统的敲门砖了。">
<meta property="og:type" content="article">
<meta property="og:title" content="【计算机系统导论】2.2 编程语言">
<meta property="og:url" content="http://wdxtub.com/1984/09/11/ics-draft-2-2/index.html">
<meta property="og:site_name" content="小土刀">
<meta property="og:description" content="学习计算机系统的一个难点在于概念本身的交叉关联，这意味着我们很难在『完全』弄懂一个概念之后再学习新的概念，而是需要一直带着疑问进行学习和探索，直到把知识融会贯通。在了解完编码之后，就可以把编程语言作为理解计算机系统的敲门砖了。">
<meta property="og:updated_time" content="2017-02-11T15:56:37.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【计算机系统导论】2.2 编程语言">
<meta name="twitter:description" content="学习计算机系统的一个难点在于概念本身的交叉关联，这意味着我们很难在『完全』弄懂一个概念之后再学习新的概念，而是需要一直带着疑问进行学习和探索，直到把知识融会贯通。在了解完编码之后，就可以把编程语言作为理解计算机系统的敲门砖了。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '4016951',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://wdxtub.com/1984/09/11/ics-draft-2-2/"/>





  <title> 【计算机系统导论】2.2 编程语言 | 小土刀 </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <!-- hexo-inject:begin --><!-- hexo-inject:end --><script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=59042340";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">小土刀</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Agony is my triumph</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-work">
          <a href="/2016/09/11/work-page" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-wifi"></i> <br />
            
            不周山
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tech">
          <a href="/2009/09/11/tech-page" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-gear"></i> <br />
            
            通天塔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-life">
          <a href="/1990/09/11/life-page" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-compass"></i> <br />
            
            好望角
          </a>
        </li>
      
        
        <li class="menu-item menu-item-booklist">
          <a href="/1997/09/11/booklist-page" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-diamond"></i> <br />
            
            书影音
          </a>
        </li>
      
        
        <li class="menu-item menu-item-thanks">
          <a href="/thanks" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://wdxtub.com/1984/09/11/ics-draft-2-2/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="wdxtub">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/misc/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="小土刀">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="小土刀" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                【计算机系统导论】2.2 编程语言
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="1984-09-11T00:02:02+08:00">
                1984-09-11
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2017-02-11T23:56:37+08:00">
                2017-02-11
              </time>
            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Technique/" itemprop="url" rel="index">
                    <span itemprop="name">Technique</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/1984/09/11/ics-draft-2-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="1984/09/11/ics-draft-2-2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>学习计算机系统的一个难点在于概念本身的交叉关联，这意味着我们很难在『完全』弄懂一个概念之后再学习新的概念，而是需要一直带着疑问进行学习和探索，直到把知识融会贯通。在了解完编码之后，就可以把编程语言作为理解计算机系统的敲门砖了。</p>
<a id="more"></a>
<hr>
<p>注：本章可能会涉及若干目前难以理解的概念，但是不要担心，随着学习的深入，各种疑惑将会迎刃而解。</p>
<h2 id="2-2-1-编程迷思"><a href="#2-2-1-编程迷思" class="headerlink" title="2.2.1 编程迷思"></a>2.2.1 编程迷思</h2><p>无论是计算机科班出身的学生，还是半路出家的爱好者，因为现在编程难度的大幅度降低，很多时候并不需要理解底层的实现就已经可以写出过得去的代码。但是网上的一些错误理解以及教材中由于内容编排对概念所做的抽象，导致了许多『想当然』的问题。要深入理解计算机系统，得先把这些『迷思』弄清楚，这样接下来的旅程会好走很多。</p>
<h3 id="计算机不只是执行程序的机器"><a href="#计算机不只是执行程序的机器" class="headerlink" title="计算机不只是执行程序的机器"></a>计算机不只是执行程序的机器</h3><p>计算机脱胎于图灵机的构想，简单来说，就是能够执行有限逻辑数学过程的计算模型。图灵机的概念很有意思，但是这里由于篇幅问题不再深入，感兴趣的话可以从维基百科[1]入门，然后就可以看看《图灵的秘密》[2]这本书，从生平到提出图灵机的论文研读都非常不错。</p>
<p>图灵机中最重要的两个『物理』硬件是纸带和读写头（这里的『物理』指的是相对于图灵机其他部分而言）。这种抽象非常简单明了，但是很容易给人一种错误印象，即由图灵机发展而来的现代计算机，就是执行程序的机器而已。</p>
<p>计算机学科的发展，与其说是众人拾柴火焰高，不如说是天才引导的历程。真正奠定现代计算机基础的则是冯诺依曼[3]，1945 年发表的 101 页报告[4]，不但提出了二进制的构想，更将计算机分成五大组件（存储器、控制器、运算器、输入、输出），我们现在使用的大部分计算机都符合冯诺依曼架构，『计算机之父』之名绝不为过。</p>
<p>当然，这个世界上总是少不了『既生瑜，何生亮』的桥段，与冯诺依曼架构（也称为普林斯顿架构）一时瑜亮另一种架构叫做哈佛架构[5]，它和冯诺依曼架构最大的区别在于能够同时访问数据和指令。虽然在计算机体系架构中黯然退场，但是哈佛结构在移动计算中扮演了非常重要的角色，ARM 架构可能是知名度最高的当红炸子鸡了。</p>
<p>和图灵机相比，这两种架构最重要的突破就是增加的存储器，这使得程序和数据的存储成为可能，也因此衍生出来了数据传输（即 IO）的概念，再加上六十年代末出现的计算机网络，计算机要完成的工作，远不止执行程序这么简单。</p>
<p>凡事有利有弊，冯诺依曼架构也有缺陷，甚至可以这么理解，目前计算机系统的诸多漏洞和不稳定，是在设计之初就注定的。比方说缓存溢出可以执行攻击者预订好的程序，给系统带来巨大的安全风险。虽然我们可以采用各种各样的技术来进行防范，但是道高一尺魔高一丈，比方说采用返回导向编程[6]的堆栈溢出攻击，在出现之后长达十多年里，主流操作系统都毫无防范之力！不过，我们在『读厚』部分能够亲自体验一把漏洞攻击，知己知彼，百战不殆嘛。</p>
<h3 id="很多东西并不像看起来那样简单"><a href="#很多东西并不像看起来那样简单" class="headerlink" title="很多东西并不像看起来那样简单"></a>很多东西并不像看起来那样简单</h3><p>学习算法的时候肯定离不开思考时间复杂度和空间复杂度，但 $O(n^3)$ 真的很糟糕，$O(1)$ 真的就很好吗？虽然在单纯的算法分析中是如此，但是在计算机系统中，算法只是一小部分。假设一个 $O(1)$ 的算法会导致死锁，虽然看起来比 $O(n^3)$ 的算法好得多，然而真正执行起来，可能就是无尽的等待了。</p>
<p>程序执行并不是一锤子买卖，从算法到数据表示再到程序流程，从内存到缓存再到运算器。不理解计算机系统本身，不理解程序是如何编译执行，又怎么能够写出好程序呢？</p>
<p>前面提到冯诺依曼架构带来了溢出的问题，二进制和十进制的差异也是的计算机中的数学，和理论上的数学有细微的差异。不要小看这点差异，如果因为忽视了它们而采用了错误的假定，基本是不可能得出准确的结果的，不过话说回来，很多时候计算机中也没有什么『准确的结果』，更多的是『可以表示的结果』。</p>
<p>我们知道，在纸面上看 $(x+1)^2 \ge 0$ 是一定的，但是在计算机中就不一定了，比方说：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># dawang at wdxtub.local in ~ [9:00:52]</span></div><div class="line">$ lldb</div><div class="line">(lldb) <span class="built_in">print</span> (233333 + 1) * (233333 + 1)</div><div class="line">(int) <span class="variable">$0</span> = -1389819292</div></pre></td></tr></table></figure>
<p>简单来说，溢出了，就成了负数。但是因为浮点数的表示方法和整数不同，并不会出现因为溢出而变成负数的问题。</p>
<p>那为啥我们不干脆都用浮点数？因为浮点数也有自己的问题，比方说 $(x+y)+z = x + (y+z)$ 在浮点数运算就不一定了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># dawang at wdxtub.local in ~ [9:05:02]</span></div><div class="line">$ lldb</div><div class="line">(lldb) <span class="built_in">print</span> (1e20 + -1e20) + 3.14</div><div class="line">(double) <span class="variable">$0</span> = 3.1400000000000001</div><div class="line">(lldb) <span class="built_in">print</span> 1e20 + (-1e20 + 3.14)</div><div class="line">(double) <span class="variable">$1</span> = 0</div></pre></td></tr></table></figure>
<p>交换一下顺序结果就完全不同了，这又是为什么？因为浮点数的表示方法虽然可以避免溢出（极端情况还是会），但会损失部分精度。</p>
<p>如果一定要在计算机系统中找一个关键词，在我看来一定是『权衡』，在之后的学习过程中，我们会常常看到因为实际与理论的差异不得不做出的妥协，而真正的智慧结晶，则是在妥协的同时找到最接近完美的权衡，可谓『带着镣铐跳舞』。</p>
<h3 id="内存里多的是我们不知道的事"><a href="#内存里多的是我们不知道的事" class="headerlink" title="内存里多的是我们不知道的事"></a>内存里多的是我们不知道的事</h3><p>很多著名网站都是由于内存错误『引发』的，比方说 stackoverflow 和 segmentfault。虽然现代编程语言大多采用了比较完善的内存保护的机制，但是从 C 时代流传下来的这些错误名称则随着时间推移成为了经典，颇有『为人不识 XX 兰，阅尽 XX 也枉然』的既视感。</p>
<p>的确，无论是 C 或者 C++ 都没有提供任何内存保护机制，再加上强大且危险的指针，出现溢出或者段错误实在是家常便饭。这类问题的问题在于，很难确定是程序本身的问题，还是编译器或者系统的问题。好吧，虽然大部分时候是程序的问题，即便如此也很难发现根源，毕竟我们的思考方式没办法做到和计算机一样。</p>
<p>我们可见的内存并不是物理内存，而是一个非物理的抽象概念。不但需要考虑边界，还得负责空间的分配和管理。假如程序的问题出在动态内存分配上，想要找出来就不那么简单的，毕竟 RAM 中的 R 意思是随机(Random)，要在随机中找确定，难免要花大把的时间。</p>
<p>更『可怕』的是，要想真正理解计算机系统中的诸多概念，得去读机器代码，当然不用读 0 和 1 啦，可是汇编是少不了的。汇编虽然是机器相关的，好在现在 Intel 的 CPU 基本一统江湖，我们不必考虑不同平台的差异。但是在学习的过程中一定能深深感受到，能编写机器无关的代码，是多么幸福的事情。汇编相比高级编程语言更加反直觉，在这里我只能鼓励大家硬着头皮上了。</p>
<h2 id="2-2-2-罗素悖论"><a href="#2-2-2-罗素悖论" class="headerlink" title="2.2.2 罗素悖论"></a>2.2.2 罗素悖论</h2><p>编程语言的基础核心来自于逻辑，来自PROGRAMMING LANGUAGES &amp; TYPE SYSTEMS文章从罗素悖论角度解释，为什么我们引入类型系统，然后才有了今天的编程语言，这对深入理解编程语言来源，破除语言误区有很大帮助。</p>
<p>著名的罗素悖论是：一个集合到底包含不包含它自己？</p>
<p>举个例子，如下集合 a 包含 a 本身：a = { a, b }</p>
<p>但是，我们常识中对树形结构的了解，一个节点（枝）是由其他节点组成的(左 右或子)，但肯定不是由它自己组成的，因此我们又认为集合a不应该包含a本身：</p>
<p>a={任何除了a的元素} 或 a={b}</p>
<p>我们总结下面：</p>
<ol>
<li>集合包含他们自己</li>
<li>集合不包含他们自己</li>
</ol>
<p>如果有很多集合，这些很多集合也可以表现为一个大集合，那么我们得到如下描述：</p>
<ol>
<li>所有集合的集合应该包含他们自己。</li>
<li>所有集合的集合不应该包含他们自己。</li>
</ol>
<p>从前面推论我们已经知道，我们倾向于第二条为真，但是注意第二句就发生了逻辑矛盾，如果我们需要统计不包含自己的所有集合，必须首先统计其主集合，因为主集合实际上是包含了所有集合的，但是主集合也是一种集合，而集合是不应该包含他们自己的，结果这里发生矛盾，这就是著名的罗素悖论。</p>
<p>解决罗素悖论是引入<a href="http://en.wikipedia.org/wiki/Type_theory" target="_blank" rel="external">类型理论</a>，引入不同类型的层次，每个层次结构中的层只是由同一类型中先前层次组成的。这就诞生了我们今天现代语言Java, C#, Ruby, Haskell 等等，都是采取类型理论，实现特定的属性和层次。</p>
<h2 id="2-2-3-实验环境配置"><a href="#2-2-3-实验环境配置" class="headerlink" title="2.2.3 实验环境配置"></a>2.2.3 实验环境配置</h2><p>这部分需要根据教材需要重写</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>这里以 Ubuntu 为例（毕竟现在的云服务器基本都是 Ubuntu Linux）进行讲解，安装非常简单，直接上命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 下载安装包</span></div><div class="line">wget https://storage.googleapis.com/golang/go1.6.3.linux-amd64.tar.gz</div><div class="line"><span class="comment"># 解压到 /usr/local（或者也可以解压到自定义目录，就是需要对应配置一下路径）</span></div><div class="line">sudo tar -C /usr/<span class="built_in">local</span> -xzf go1.6.3.linux-amd64.tar.gz</div><div class="line"><span class="comment"># 更新 PATH 环境变量，在 ~/.bashrc 中添加下面这行</span></div><div class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin</div><div class="line"><span class="comment"># 启用更新</span></div><div class="line"><span class="built_in">source</span> ~/.bashrc</div><div class="line"><span class="comment"># 检测版本</span></div><div class="line">go version</div></pre></td></tr></table></figure>
<p>如果最后一条命令会显示 go 版本，那么第一步配置就完成了。</p>
<p>第二步我们需要配置 <code>$GOPATH</code> 这个环境变量，这个变量类似于指定 Go 项目的 workspace，比方说新建一个 <code>~/Go</code> 文件夹，然后在 <code>~/.bashrc</code> 中添加 <code>export GOPATH=$HOME/Go</code> 即可（别忘了 <code>source ~/.bashrc</code>）</p>
<p>好消息是，并没有第三步，我们可以开始 Hello World 了！</p>
<h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><p>Mac 下的安装和 Linux 相比更为简单一些，因为有直接的安装包，双击然后一路下一步就好。不过这里我们还是绕点远路，配合 zsh 把 Go 环境搭建起来。上命令！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 下载安装包，wget 可能需要通过 homebrew 安装</span></div><div class="line">wget https://storage.googleapis.com/golang/go1.6.3.darwin-amd64.tar.gz</div><div class="line"><span class="comment"># 解压到 /usr/local（或者也可以解压到自定义目录，就是需要对应配置一下路径）</span></div><div class="line">sudo tar -C /usr/<span class="built_in">local</span> -xzf go1.6.3.darwin-amd64.tar.gz</div><div class="line"><span class="comment"># 更新 PATH 环境变量，在 ~/.zshrc 中添加下面这行（注意要添加在原 PATH 之后）</span></div><div class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin</div><div class="line"><span class="comment"># 启用更新</span></div><div class="line"><span class="built_in">source</span> ~/.zshrc</div><div class="line"><span class="comment"># 检测版本</span></div><div class="line">go version</div></pre></td></tr></table></figure>
<p>如果最后一条命令会显示 go 版本，那么第一步配置就完成了。</p>
<p>第二步我们需要配置 <code>$GOPATH</code> 这个环境变量，这个变量类似于指定 Go 项目的 workspace，比方说新建一个 <code>~/Go</code> 文件夹，然后在 <code>~/.zshrc</code> 中添加 <code>export GOPATH=$HOME/Go</code> 即可（别忘了 <code>source ~/.zshrc</code>）</p>
<p>好消息是，并没有第三步，我们可以开始 Hello World 了！</p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>本系列写了没几天 Go 就更新到了 1.7 版本，所以这里也更新一下，方法很简单，直接下载覆盖即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 下载安装包，wget 可能需要通过 homebrew 安装</span></div><div class="line">wget https://storage.googleapis.com/golang/go1.7.darwin-amd64.tar.gz</div><div class="line"><span class="comment"># 删除老版本</span></div><div class="line">sudo rm -rf /usr/<span class="built_in">local</span>/go</div><div class="line"><span class="comment"># 解压到 /usr/local（或者也可以解压到自定义目录，就是需要对应配置一下路径）</span></div><div class="line">sudo tar -C /usr/<span class="built_in">local</span> -xzf go1.7.darwin-amd64.tar.gz</div><div class="line"><span class="comment"># 检测版本</span></div><div class="line">go version</div></pre></td></tr></table></figure>
<p>应该可以正常看到输出为 <code>go version go1.7 darwin/amd64</code> 了，即更新完成。</p>
<h3 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h3><p>虽然我们可以直接根据使用命令行和文本编辑器进行编程，但是有了 IDE 的帮助，除了代码高亮之外，智能提示也是很好的辅助。这里我们没有选用诸如 Eclipse + 插件这样的解决方案，而是直接用跨平台的的 Visual Studio Code 配合 Go 自带的一些工具完成一个全功能的 IDE 搭建。</p>
<p>配置很简单，在 VSCode 的应用商店中搜索 <code>Go for Visual Studio Code</code> 扩展，安装完成之后配置对应的 <code>GOPATH</code> 并安装指定的应用包，即可拥有以下功能（对我来说已经足够了）</p>
<ul>
<li>Completion Lists (using <code>gocode</code>)</li>
<li>Signature Help (using <code>godoc</code>)</li>
<li>Snippets</li>
<li>Quick Info (using <code>godef</code>)</li>
<li>Goto Definition (using <code>godef</code>)</li>
<li>Find References (using <code>guru</code>)</li>
<li>File outline (using <code>go-outline</code>)</li>
<li>Workspace symbol search (using <code>go-symbols</code>)</li>
<li>Rename (using <code>gorename</code>)</li>
<li>Build-on-save (using <code>go build</code> and <code>go test</code>)</li>
<li>Lint-on-save (using <code>golint</code> or <code>gometalinter</code>)</li>
<li>Format (using <code>goreturns</code> or <code>goimports</code> or <code>gofmt</code>)</li>
<li>Generate unit tests squeleton (using <code>gotests</code>)</li>
<li>Add Imports (using <code>gopkgs</code>)</li>
<li>Debugging (using <code>delve</code>)</li>
</ul>
<p>从代码自动排版到错误提示一应俱全，与此同时非常轻量，可谓居家旅行必备神器。</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>Go 已经自带了很多非常好用的工具，也可以通过简单的命令进行调用，当然也可以据此轻松配置自己喜欢的编辑器。完整的命令列表可以通过输入 <code>go</code> 来查看，这里简单介绍一下。</p>
<ul>
<li><code>go build hello.go</code> 就可以编译出最终执行文件，这样直接执行 <code>./hello</code> 就可以看到结果</li>
<li><code>go clean</code> 可以清理编译后的文件</li>
<li><code>go doc fmt</code> 可以查看 fmt 包的文档</li>
<li><code>go env</code> 显示 Go 相关的环境变量</li>
<li><code>go fmt</code> 利用 gofmt 工具自动排版代码</li>
<li><code>go get</code> 下载并安装 package</li>
<li><code>go install</code> 编译并安装 package</li>
<li><code>go list</code> 列出 package</li>
<li><code>go run hello.go</code> 编译并运行 Go 程序</li>
<li><code>go test fmt</code> 测试 fmt package</li>
<li><code>go tool</code> 运行指定的 Go 工具，包括 addr2line, asm, cgo, compile, cover, dist, doc, fix, link, nm, objdump, pack, pprof, tour, trace, vet, yacc</li>
</ul>
<p>其实这些工具已经基本上集成到 Visual Studio 的 Go 插件中了，只要简单配置一下，就可以自动运行或者通过快捷键调用。</p>
<h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>环境配置好了，就可以来写我们的第一个 Go 程序了，在 <code>~/Go</code> 文件夹下新建一个名为 <code>hello.go</code> 的文件，内容为</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main<span class="keyword">import</span> <span class="string">"fmt"</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// Say Hello</span>    fmt.Printf(<span class="string">"Hello World! This is wdxtub!\n"</span>)&#125;</div></pre></td></tr></table></figure>
<p>然后我们执行 <code>go run hello.go</code> 就可以看到输出了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">dawang:~/Go$ go run hello.go Hello World! This is wdxtub!</div></pre></td></tr></table></figure>
<p>从这个简单的程序中，我们知道：</p>
<ul>
<li>非注释的第一行代码定义包名，每个程序属于一个 package。每个 Go 应用都包含一个名为 main 的包</li>
<li>用 <code>import</code> 关键字来引用包，这里的 <code>fmt</code> 包含了格式化输入输出的相关函数</li>
<li>用 <code>func</code> 关键词来声明函数，而 <code>main</code> 函数是每一个可执行程序必须包含的，一般来说会最先执行（有 <code>init()</code> 函数除外）</li>
<li>和 C 语言一样，用 <code>//</code> 来进行单行注释，用 <code>/* ... */</code> 来进行多行注释</li>
<li>不用分号</li>
<li>当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）</li>
</ul>
<p>很简单对不对！接下来我们先简单了解一下 Go 的设计哲学，然后就正式进入快速入门教程。</p>
<h2 id="2-2-4-Go-语言快速入门"><a href="#2-2-4-Go-语言快速入门" class="headerlink" title="2.2.4 Go 语言快速入门"></a>2.2.4 Go 语言快速入门</h2><p>软件工程随着时间的推移为了照顾之前的旧代码旧设计积累了太多太多的繁文缛节，把原来大道至简的计算机科学弄成了拄着几十条拐杖的老头：</p>
<ul>
<li>为什么我们需要几十上百个保留字？</li>
<li>为了省几行代码创造各种语法糖，为此增加如此多的记忆成本有多少意义？</li>
<li>为什么我们需要一层一层封装，像制造洋葱一样写代码？</li>
<li>我们是不是被面向对象洗脑了，很多事情其实用函数式思维来解决更好不是么？</li>
</ul>
<p>重点是，这些东西本质上没有办法减少任何实际问题的难度，为什么不能简简单单干净漂亮地把事情做好，而是去追求所谓大而全呢？一门好的编程语言应该是程序员的武器，而不是负担；应该是辅助思考的工具，不是记忆成本。人总是会犯错的，正道并不是通过各种各样的封装把问题『藏』起来，而是干脆暴露出来，解决它们。</p>
<p>我非常推崇 Unix 的编程哲学：追求简洁、清晰、透明、低复杂度，通过拼接组合功能，避免标新立异。而 Go 作为 Unix 哲学的继承和实践者，无疑是一种大道至简、重剑无锋价值观的回归。</p>
<p>基本语法其实非常简单清晰，这里直接以要点的形式列出：</p>
<ul>
<li>一行一个语句，不用写分号。如果一行写多个语句，需要用分号隔开，但是并不鼓励这种做法</li>
<li>标识符的第一个字符必须是字母或者下划线，从第二个开始才能用数字</li>
<li>行注释以 <code>//</code> 开始，块注释为 <code>/**/</code></li>
<li>Go 中有 25 个关键字：break, default, func, interface, select, case, defer, go, map, struct, chan, else, goto, package, switch, const, fallthrough, if, range, type, continue, for, import, return var</li>
<li>Go 中有 36 个预定义标识符：append, bool, byte, cap, close, complex, complex64, complex128, uint, uint8, uint16, uint32, uint64, uintptr, copy, false, float32, float64, imag, int, int8, int16, int32, int64, iota, len, make, new, nil, panic, print, println, real, recover, string, true</li>
<li>空标识符 <code>_</code> 是一个占位符，可以用来丢弃不需要的值</li>
<li>数据类型有以下几种，非常简洁：<ul>
<li>布尔型 <code>bool</code>，值为 true 或者 false</li>
<li>数字类型 <code>int</code>, <code>float</code>，原生支持复数，如果后面跟了数字，就是指位数</li>
<li>字符串类型 <code>string</code>，用 UTF8 编码</li>
<li>派生类型：指针、数组、结构体、联合、函数、切片、接口、Map、Channel</li>
<li>类型转换采用 type(value) 的形式，只要合法，就一定会转换成功，哪怕会有精度丢失</li>
<li>几个比较特殊的：<ul>
<li><code>byte</code> 类似 <code>uint8</code></li>
<li><code>rune</code> 类似 <code>int32</code></li>
<li><code>uint</code> 32 位或 64 位</li>
<li><code>int</code> 与 <code>uint</code> 大小一样</li>
<li><code>uintptr</code> 无符号整型，用于存放一个指针</li>
</ul>
</li>
</ul>
</li>
<li>变量声明使用 <code>var</code> 关键字，模板为 <code>var identifier type</code>，也就是类型在后面，比如<ul>
<li><code>var a int</code> 标准声明，使用默认值 0</li>
<li><code>var b int = 10</code> 声明且赋值</li>
<li><code>var c = 10</code> 不指明类型，根据赋值类型自动判断</li>
<li><code>d := 10</code> 省略 <code>var</code> 而使用 <code>:=</code>，这里的 <code>d</code> 不能是已经声明过的</li>
<li>可以用 <code>&amp;</code> 来取得值对应的地址（也就是指针），这个后面会详细介绍</li>
<li>Go 会自动用 0 或空字符串来初始化</li>
</ul>
</li>
<li>常量声明使用 <code>const</code> 关键字，模板为 <code>const identifier [type] = value</code>，其中类型是可选的，因为 Go 可以自动推断出类型，比如<ul>
<li><code>const a string = &quot;hello&quot;</code> 显式定义</li>
<li><code>const b = &quot;world&quot;</code> 隐式定义</li>
</ul>
</li>
<li>特殊常量 <code>iota</code>，每一个 const 出现是会被重置为 0，每出现一次 <code>iota</code>，其值会加一，可以用作枚举值</li>
</ul>
<p>因为文字描述比较模糊，这里给出一个 <code>iota</code> 的用法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">const</span> (</div><div class="line">        a = <span class="literal">iota</span></div><div class="line">        b = <span class="number">3</span> &lt;&lt; <span class="literal">iota</span></div><div class="line">        c</div><div class="line">        d = <span class="number">100</span></div><div class="line">        e</div><div class="line">        f</div><div class="line">        g</div><div class="line">    )</div><div class="line">    </div><div class="line">    fmt.Println(a, b, c, d, e, f, g)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应的输出为 <code>0 6 2 100 4 5 6</code>，请仔细感受一下这个加一的过程。Go 的运算符也比较『正常』，这里简单点一下</p>
<ul>
<li>算术运算符：<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>++</code>, <code>--</code></li>
<li>关系运算符：<code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></li>
<li>逻辑运算符：<code>&amp;&amp;</code>, <code>||</code>, <code>!</code></li>
<li>赋值运算符：<code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>^=</code>, <code>|=</code></li>
<li>位运算符：<code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li>
<li>其他运算符：<code>&amp;</code>(返回变量的存储地址)，<code>*</code> 指针变量</li>
</ul>
<p>运算符优先级也没有什么特别的地方，正常用一般不会有太多『意外』。如果上面的内容令你有些困惑，不要紧，接下来会简单进行介绍，但是最快最准确的方法，是去官方文档里查阅对应内容。</p>
<h3 id="整型与浮点数"><a href="#整型与浮点数" class="headerlink" title="整型与浮点数"></a>整型与浮点数</h3><p>Go 中提供了 11 种整型，包括 5 种有符号的和 5 种无符号的，再加上 1种用于存储指针的整型类型。<code>byte</code> 相当于 <code>unit8</code>，单个字符（即 Unicode 码点）提倡使用 <code>rune</code> 来代替 <code>int32</code>，不过一般来说我们只需要使用 <code>int</code> 即可，会根据平台来自动决定位数。</p>
<p>要处理大整数时，我们可以使用 <code>big.Int</code> 或 <code>big.Rat</code> 类型，但是处理的速度要比 <code>int</code> 慢得多。</p>
<p>Go 中提供了 2 种类型的浮点类型和 2 种类型的复数类型。一般我们会使用 <code>math</code> 包来处理 <code>float64</code> 类型的数据。对于复数类型，我们一般使用 <code>math/cmplx</code> 包来处理，默认类型是 <code>complex128</code></p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串的处理我们一般使用 <a href="https://golang.org/pkg/strings/" target="_blank" rel="external"><code>strings</code></a> 和 <a href="https://golang.org/pkg/strconv/" target="_blank" rel="external"><code>strconv</code></a> 这两个包，如果要处理 UTF-8，那么 <a href="https://golang.org/pkg/unicode/utf8/" target="_blank" rel="external"><code>utf8</code></a> 是需要了解的。Go 中的字符串都是以 UTF-8 编码的 Unicode 文本，虽然这样可能带来的问题是我们不再能够用数组下标来定位某个字符，但是我们可以通过码点切片（<code>[]rune</code>）来进行索引。</p>
<p>一些常见的操作有：</p>
<ul>
<li><code>s[n]</code> 字符串 s 中索引位置为 n(uint8 类型)处的原始字节</li>
<li><code>s[n:m]</code> 从位置 n 到位置 m-1 处取得的字符串</li>
<li><code>len(s)</code> 字符串 s 中的字节数</li>
<li><code>len([]rune(s))</code> 字符串 s 中字符的个数，使用 <code>utf8.RuneCountInString()</code> 会更快</li>
<li><code>[]rune(s)</code> 将字符串 s 转换成一个 Unicode 码点</li>
<li><code>string(char)</code> 将一个 <code>[]rune</code> 或者 <code>[]int32</code> 转换成字符串，这里需要保证都是码点</li>
<li><code>[]byte(s)</code> 无副本地将字符串 s 转换成一个原始字节的切片数组</li>
</ul>
<p>Go 中的字符串比较实际上是在内存中一个字节一个字节地比较字符串。对于字符串操作，有一个很常见的场景是把多个字符串拼接起来，除了使用 <code>+=</code> 操作符，Go 中还有两种比较好的方式：</p>
<ol>
<li>准备好一个字符串切片（<code>[]string</code>），然后使用 <code>strings.Join()</code> 函数一次性完成串联</li>
<li>使用 <code>bytes.Buffer</code> 的 <code>WriteString()</code> 方法把我们需要的内容写入到 buffer 中，然后使用 <code>bytes.Buffer.String()</code> 方法生成字符串</li>
</ol>
<p>如果需要格式化字符串，我们一般使用 <a href="https://golang.org/pkg/fmt/" target="_blank" rel="external"><code>fmt</code></a> 包，格式指令主要有：</p>
<ul>
<li><code>%b</code> 一个二进制的整数值</li>
<li><code>%c</code> 一个 Unicode 字符的码点值</li>
<li><code>%d</code> 一个十进制数值</li>
<li><code>%e</code>/<code>%E</code> 以科学计数法 e/E 表示的值</li>
<li><code>%f</code> 一个浮点数值</li>
<li><code>%o</code> 一个八进制表示的数字</li>
<li><code>%p</code> 一个十六进制表示的值的地址</li>
<li><code>%s</code> 字符串</li>
<li><code>%t</code> 使用 true 或 false 输出布尔值</li>
</ul>
<p>其他常用的字符串相关的包有 <a href="https://golang.org/pkg/unicode/" target="_blank" rel="external"><code>unicode</code></a> 和正则表达式包 <a href="https://golang.org/pkg/regexp/" target="_blank" rel="external"><code>regexp</code></a></p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>Go 具有指针。 指针保存了变量的内存地址。类型 <code>*T</code> 是指向类型 <code>T</code> 的值的指针。其零值是 <code>nil</code>。例如：<code>var p *int</code></p>
<p><code>&amp;</code> 符号会生成一个指向其作用对象的指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">i := <span class="number">42</span></div><div class="line">p = &amp;i</div></pre></td></tr></table></figure>
<p><code>*</code> 符号表示指针指向的底层的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">fmt.Println(*p) <span class="comment">// 通过指针 p 读取 i</span></div><div class="line">*p = <span class="number">21</span>         <span class="comment">// 通过指针 p 设置 i</span></div></pre></td></tr></table></figure>
<p>这也就是通常所说的“间接引用”或“非直接引用”。与 C 不同，Go 没有指针运算。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	i, j := <span class="number">42</span>, <span class="number">2701</span></div><div class="line"></div><div class="line">	p := &amp;i         <span class="comment">// point to i</span></div><div class="line">	fmt.Println(*p) <span class="comment">// read i through the pointer</span></div><div class="line">	*p = <span class="number">21</span>         <span class="comment">// set i through the pointer</span></div><div class="line">	fmt.Println(i)  <span class="comment">// see the new value of i</span></div><div class="line"></div><div class="line">	p = &amp;j         <span class="comment">// point to j</span></div><div class="line">	*p = *p / <span class="number">37</span>   <span class="comment">// divide j through the pointer</span></div><div class="line">	fmt.Println(j) <span class="comment">// see the new value of j</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="数组与切片"><a href="#数组与切片" class="headerlink" title="数组与切片"></a>数组与切片</h3><p>Go 中的数组是按值传递的，也就是说会复制一份，所以传递大数组开销很大，不过我们一般都使用切片，因为传递一个切片的成本很低。这里需要强调两个符号：</p>
<ul>
<li><code>&amp;</code> 作为一元操作符，会取得对应变量的地址，常被称为取址操作符</li>
<li><code>*</code> 作为一元操作符，会返回其保存的地址所指向的内存的值，常被称为内容操作符、间接操作符或者解引用操作符</li>
</ul>
<p><code>new(Type)</code> 和 <code>&amp;Type{}</code> 是等价的，都会分配一个 Type 类型的空值，并返回一个指向该值的指针。</p>
<p>创建数组的语法为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">[length]Type</div><div class="line">[N]Type&#123;value1, value2, ..., valueN&#125;</div><div class="line">[...]Type&#123;value1, value2, ..., valueN&#125;</div></pre></td></tr></table></figure>
<p>一般来说，切片比数组更加灵活、强大且方便，创建切片的语法为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="built_in">make</span>([]Type, length, capacity)</div><div class="line"><span class="built_in">make</span>([]Type, length)</div><div class="line">[]Type&#123;&#125;</div><div class="line">[]Type&#123;value1, value2, ..., valueN&#125;</div></pre></td></tr></table></figure>
<p>但是实际上切片的底层仍然是一个固定长度的数组，但是会自动根据我们的需求来进行扩展核收缩。下面是一些示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	p := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</div><div class="line">	fmt.Println(<span class="string">"p =="</span>, p)</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(p); i++ &#123;</div><div class="line">		fmt.Printf(<span class="string">"p[%d] == %d\n"</span>, i, p[i])</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	fmt.Println(<span class="string">"p[1:4] =="</span>, p[<span class="number">1</span>:<span class="number">4</span>])</div><div class="line"></div><div class="line">	<span class="comment">// 省略下标代表从 0 开始</span></div><div class="line">	fmt.Println(<span class="string">"p[:3] =="</span>, p[:<span class="number">3</span>])</div><div class="line"></div><div class="line">	<span class="comment">// 省略上标代表到 len(s) 结束</span></div><div class="line">	fmt.Println(<span class="string">"p[4:] =="</span>, p[<span class="number">4</span>:])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>slice 由函数 make 创建。这会分配一个零长度的数组并且返回一个 slice 指向这个数组： <code>a := make([]int, 5)  // len(a)=5</code> 为了指定容量，可传递第三个参数到 <code>make</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="comment">// len(b)=0, cap(b)=5</span></div><div class="line"></div><div class="line">b = b[:<span class="built_in">cap</span>(b)] <span class="comment">// len(b)=5, cap(b)=5</span></div><div class="line">b = b[<span class="number">1</span>:]      <span class="comment">// len(b)=4, cap(b)=4</span></div></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</div><div class="line">	printSlice(<span class="string">"a"</span>, a)</div><div class="line">	b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>)</div><div class="line">	printSlice(<span class="string">"b"</span>, b)</div><div class="line">	c := b[:<span class="number">2</span>]</div><div class="line">	printSlice(<span class="string">"c"</span>, c)</div><div class="line">	d := c[<span class="number">2</span>:<span class="number">5</span>]</div><div class="line">	printSlice(<span class="string">"d"</span>, d)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s <span class="keyword">string</span>, x []<span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	fmt.Printf(<span class="string">"%s len=%d cap=%d %v\n"</span>,</div><div class="line">		s, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>slice 的零值是 <code>nil</code>。一个 nil 的 slice 的长度和容量是 0。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> z []<span class="keyword">int</span></div><div class="line">	fmt.Println(z, <span class="built_in">len</span>(z), <span class="built_in">cap</span>(z))</div><div class="line">	<span class="keyword">if</span> z == <span class="literal">nil</span> &#123;</div><div class="line">		fmt.Println(<span class="string">"nil!"</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>向 slice 添加元素是一种常见的操作，因此 Go 提供了一个内建函数 <code>append</code>。 内建函数的文档对 append 有详细介绍。<code>func append(s []T, vs ...T) []T</code></p>
<ul>
<li>append 的第一个参数 s 是一个类型为 T 的数组，其余类型为 T 的值将会添加到 slice。</li>
<li>append 的结果是一个包含原 slice 所有元素加上新添加的元素的 slice。</li>
<li>如果 s 的底层数组太小，而不能容纳所有值时，会分配一个更大的数组。 返回的 slice 会指向这个新分配的数组。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> a []<span class="keyword">int</span></div><div class="line">	printSlice(<span class="string">"a"</span>, a)</div><div class="line"></div><div class="line">	<span class="comment">// append works on nil slices.</span></div><div class="line">	a = <span class="built_in">append</span>(a, <span class="number">0</span>)</div><div class="line">	printSlice(<span class="string">"a"</span>, a)</div><div class="line"></div><div class="line">	<span class="comment">// the slice grows as needed.</span></div><div class="line">	a = <span class="built_in">append</span>(a, <span class="number">1</span>)</div><div class="line">	printSlice(<span class="string">"a"</span>, a)</div><div class="line"></div><div class="line">	<span class="comment">// we can add more than one element at a time.</span></div><div class="line">	a = <span class="built_in">append</span>(a, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line">	printSlice(<span class="string">"a"</span>, a)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s <span class="keyword">string</span>, x []<span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	fmt.Printf(<span class="string">"%s len=%d cap=%d %v\n"</span>,</div><div class="line">		s, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>for 循环的 range 格式可以对 slice 或者 map 进行迭代循环。可以通过赋值给 <code>_</code> 来忽略序号和值。如果只需要索引值，去掉“, value”的部分即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> pow = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</div><div class="line">		fmt.Printf(<span class="string">"2**%d = %d\n"</span>, i, v)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果想要排序和搜索切片，一般使用 <a href="https://golang.org/pkg/sort/" target="_blank" rel="external"><code>sort</code></a> 包来进行对切片的排序和搜索。如果要对自定义的结构体排序，只需要对应实现 <code>Len()</code>, <code>Less()</code> 和 <code>Swap()</code> 三个函数。</p>
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>和 Map/Dictionary 类似，保存键值对的无序集合，所有的键需要是唯一的而且必须支持 <code>==</code> 和 <code>!=</code> 操作，一些常用的操作有：</p>
<ul>
<li><code>m[k] = v</code> 创建一个 k-v 的映射记录，如果已存在，则更新数据</li>
<li><code>Delete(m, k)</code> 删除 m 中键为 k 的映射</li>
<li><code>v := m[k]</code> 取出 m 中键为 k 的映射，赋值给 v</li>
<li><code>v, found := m[k]</code> 取出 m 中键为 k 的映射，复制为 v，<code>found</code> 用来表示映射否存在</li>
<li><code>len(m)</code> 返回 m 中 k-v 映射记录的个数</li>
</ul>
<p>映射可以通过如下方式创建：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, initialCapacity)</div><div class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType)</div><div class="line"><span class="keyword">map</span>[KeyType]valueType&#123;&#125;</div><div class="line"><span class="keyword">map</span>[KeyType]valueType&#123;key1: value1, key2: value2, ..., keyN: valueN&#125;</div></pre></td></tr></table></figure>
<p>一些例子为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</div><div class="line">	Lat, Long <span class="keyword">float64</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex</div><div class="line"></div><div class="line"><span class="keyword">var</span> mmm = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</div><div class="line">	<span class="string">"Bell Labs"</span>: &#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>&#125;,</div><div class="line">	<span class="string">"Google"</span>:    &#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</div><div class="line">	m[<span class="string">"Bell Labs"</span>] = Vertex&#123;</div><div class="line">		<span class="number">40.68433</span>, <span class="number">-74.39967</span>,</div><div class="line">	&#125;</div><div class="line">	fmt.Println(m[<span class="string">"Bell Labs"</span>])</div><div class="line">	</div><div class="line">	<span class="keyword">var</span> mm = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</div><div class="line">    	<span class="string">"Bell Labs"</span>: Vertex&#123;</div><div class="line">    		<span class="number">40.68433</span>, <span class="number">-74.39967</span>,</div><div class="line">    	&#125;,</div><div class="line">    	<span class="string">"Google"</span>: Vertex&#123;</div><div class="line">    		<span class="number">37.42202</span>, <span class="number">-122.08408</span>,</div><div class="line">    	&#125;,</div><div class="line">    &#125;</div><div class="line">    fmt.Println(mm)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 map m 中插入或修改一个元素：<code>m[key] = elem</code>。获得元素：<code>elem = m[key]</code>。删除元素：<code>delete(m, key)</code>。通过双赋值检测某个键存在：<code>elem, ok = m[key]</code> 如果 key 在 m 中，<code>ok</code> 为 true 。否则， ok 为 <code>false</code>，并且 elem 是 map 的元素类型的零值。同样的，当从 map 中读取某个不存在的键时，结果是 map 的元素类型的零值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</div><div class="line"></div><div class="line">	m[<span class="string">"Answer"</span>] = <span class="number">42</span></div><div class="line">	fmt.Println(<span class="string">"The value:"</span>, m[<span class="string">"Answer"</span>])</div><div class="line"></div><div class="line">	m[<span class="string">"Answer"</span>] = <span class="number">48</span></div><div class="line">	fmt.Println(<span class="string">"The value:"</span>, m[<span class="string">"Answer"</span>])</div><div class="line"></div><div class="line">	<span class="built_in">delete</span>(m, <span class="string">"Answer"</span>)</div><div class="line">	fmt.Println(<span class="string">"The value:"</span>, m[<span class="string">"Answer"</span>])</div><div class="line"></div><div class="line">	v, ok := m[<span class="string">"Answer"</span>]</div><div class="line">	fmt.Println(<span class="string">"The value:"</span>, v, <span class="string">"Present?"</span>, ok)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们要按顺序遍历一个 map，那么可以先把所有的 key 取出来放到一个切片中，排序之后，然后再一个一个取出来。</p>
<h3 id="类型转换与断言"><a href="#类型转换与断言" class="headerlink" title="类型转换与断言"></a>类型转换与断言</h3><p>Go 可以在相互兼容的数据类型中进行类型转换，对于非数值类型不会丢失精度，对于数值类型可能会丢失精度。转换的方式很简单：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">resultOfType := Type(expression)</div></pre></td></tr></table></figure>
<p>一个字符串可以转换成一个 <code>[]byte</code> 或者一个 <code>[]rune</code>，也可以进行反过来的转换。</p>
<p>除了类型转换，另一个很有用的特性是类型断言。在 Go 中 <code>interface{}</code> 类型用于表示空接口，实际上可以用于表示任意 Go 类型的值。于是我们可以使用类型开关、类型断言或者 <a href="https://golang.org/pkg/reflect/" target="_blank" rel="external"><code>reflect</code></a> 包进行类型检查，然后把数据转换成我们需要的值，比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">resultOfType, boolean := expression.(Type) <span class="comment">// 安全类型断言</span></div><div class="line">resultOfType := expression.(Type) <span class="comment">// 非安全类型断言，失败时 panic()</span></div></pre></td></tr></table></figure>
<p>比如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="number">99</span></div><div class="line"><span class="keyword">var</span> s <span class="keyword">interface</span>&#123;&#125; = []<span class="keyword">string</span>&#123;<span class="string">"left"</span>, <span class="string">"right"</span>&#125;</div><div class="line">j := i.(<span class="keyword">int</span>)</div><div class="line">fmt.Printf(<span class="string">"%T-&gt;%d\n"</span>, j, j)</div><div class="line"><span class="keyword">if</span> i, ok := i.(<span class="keyword">int</span>); ok &#123;</div><div class="line">    fmt.Printf(<span class="string">"%T-&gt;%d\n"</span>, i, j) <span class="comment">// i 是一个 int 类型的影子变量</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> s, ok := s.([]<span class="keyword">string</span>); ok &#123;</div><div class="line">    fmt.Printf(<span class="string">"%T-&gt;%q\n"</span>, s, s) <span class="comment">// s 是一个 []string 类型的影子变量</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h3><p>Go 中的条件语句主要分三种：<code>if</code>, <code>switch</code> 和 <code>select</code>，比较特别的是 <code>select</code>，会随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。</p>
<p><strong>if</strong></p>
<p>if 语句除了没有了 <code>( )</code> 之外（甚至强制不能使用它们），看起来跟 C 或者 Java 中的一样，而 <code>{ }</code> 是必须的。<code>if</code> 语句可以在条件之前执行一个简单的语句。由这个语句定义的变量的作用域仅在 if 范围之内。在 if 的便捷语句定义的变量同样可以在任何对应的 else 块中使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"math"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">string</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> sqrt(-x) + <span class="string">"i"</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> fmt.Sprint(math.Sqrt(x))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</div><div class="line">		<span class="keyword">return</span> v</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		fmt.Printf(<span class="string">"%g &gt;= %g\n"</span>, v, lim)</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 这里开始就不能使用 v 了</span></div><div class="line">	<span class="keyword">return</span> lim</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Println(sqrt(<span class="number">2</span>), sqrt(<span class="number">-4</span>))</div><div class="line">	fmt.Println(</div><div class="line">		pow(<span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>),</div><div class="line">		pow(<span class="number">3</span>, <span class="number">3</span>, <span class="number">20</span>),</div><div class="line">	)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>switch</strong></p>
<p>对于 switch 语句来说，除非以 fallthrough 语句结束，否则分支会自动终止。switch 的条件从上到下的执行，当匹配成功的时候停止。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"runtime"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Print(<span class="string">"Go runs on "</span>)</div><div class="line">	<span class="keyword">switch</span> os := runtime.GOOS; os &#123;</div><div class="line">	<span class="keyword">case</span> <span class="string">"darwin"</span>:</div><div class="line">		fmt.Println(<span class="string">"OS X."</span>)</div><div class="line">	<span class="keyword">case</span> <span class="string">"linux"</span>:</div><div class="line">		fmt.Println(<span class="string">"Linux."</span>)</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="comment">// freebsd, openbsd,</span></div><div class="line">		<span class="comment">// plan9, windows...</span></div><div class="line">		fmt.Printf(<span class="string">"%s."</span>, os)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>没有条件的 switch 同 <code>switch true</code> 一样。这一构造使得可以用更清晰的形式来编写长的 if-then-else 链。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	t := time.Now()</div><div class="line">	<span class="keyword">switch</span> &#123;</div><div class="line">	<span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</div><div class="line">		fmt.Println(<span class="string">"Good morning!"</span>)</div><div class="line">	<span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</div><div class="line">		fmt.Println(<span class="string">"Good afternoon."</span>)</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		fmt.Println(<span class="string">"Good evening."</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>switch 用于类型开关</strong></p>
<p>switch 还可以用于类型开关，帮助我们处理不同类型的数据，直接看一个例子就很清晰了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">classifier</span><span class="params">(items...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> items &#123;</div><div class="line">        <span class="keyword">switch</span> x.(<span class="keyword">type</span>) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="keyword">bool</span>:</div><div class="line">            fmt.Printf(<span class="string">"param #%d is a bool\n"</span>, i)</div><div class="line">        <span class="keyword">case</span> <span class="keyword">float64</span>:</div><div class="line">            fmt.Printf(<span class="string">"param #%d is a float64\n"</span>, i)</div><div class="line">        <span class="keyword">case</span> <span class="keyword">int</span>, <span class="keyword">int8</span>, <span class="keyword">int16</span>, <span class="keyword">int32</span>, <span class="keyword">int64</span>:</div><div class="line">            fmt.Printf(<span class="string">"param #%d is a int\n"</span>, i)</div><div class="line">        <span class="keyword">case</span> <span class="keyword">uint</span>, <span class="keyword">uint8</span>, <span class="keyword">uint16</span>, <span class="keyword">uint32</span>, <span class="keyword">uint64</span>:</div><div class="line">            fmt.Printf(<span class="string">"param #%d is a unsigned int\n"</span>, i)</div><div class="line">        <span class="keyword">case</span> <span class="literal">nil</span>:</div><div class="line">            fmt.Printf(<span class="string">"param #%d is a nil\n"</span>, i)</div><div class="line">        <span class="keyword">case</span> <span class="keyword">string</span>:</div><div class="line">            fmt.Printf(<span class="string">"param #%d is a string\n"</span>, i)</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            fmt.Printf(<span class="string">"param #%d is a unknown\n"</span>, i)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但大部分 Go 程序应该都不需要类型断言和类型开关，即使需要，应该也很少用到。其中一个使用案例是，我们传入一个满足某个接口的值，同时想检查下它是否满足另外一个接口。另一个使用案例是，数据来自于外部源但必须转换成 Go 语言的数据类型。为了简化维护，最好总是将这些代码与其他程序分开。这样就使得程序完全地工作于 Go 语言的数据类型之上，也意味着任何外部源数据的格式或类型改变所导致的代码维护工作可以控制在小范围内。</p>
<p><strong>select</strong></p>
<p>select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。例如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">   <span class="keyword">var</span> c1, c2, c3 <span class="keyword">chan</span> <span class="keyword">int</span></div><div class="line">   <span class="keyword">var</span> i1, i2 <span class="keyword">int</span></div><div class="line">   <span class="keyword">select</span> &#123;</div><div class="line">      <span class="keyword">case</span> i1 = &lt;-c1:</div><div class="line">         fmt.Printf(<span class="string">"received "</span>, i1, <span class="string">" from c1\n"</span>)</div><div class="line">      <span class="keyword">case</span> c2 &lt;- i2:</div><div class="line">         fmt.Printf(<span class="string">"sent "</span>, i2, <span class="string">" to c2\n"</span>)</div><div class="line">      <span class="keyword">case</span> i3, ok := (&lt;-c3):  <span class="comment">// same as: i3, ok := &lt;-c3</span></div><div class="line">         <span class="keyword">if</span> ok &#123;</div><div class="line">            fmt.Printf(<span class="string">"received "</span>, i3, <span class="string">" from c3\n"</span>)</div><div class="line">         &#125; <span class="keyword">else</span> &#123;</div><div class="line">            fmt.Printf(<span class="string">"c3 is closed\n"</span>)</div><div class="line">         &#125;</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">         fmt.Printf(<span class="string">"no communication\n"</span>)</div><div class="line">   &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>每个case都必须是一个通信</li>
<li>所有channel表达式都会被求值</li>
<li>所有被发送的表达式都会被求值</li>
<li>如果任意某个通信可以进行，它就执行；其他被忽略。</li>
<li>如果有多个case都可以运行，Select会随机公平地选出一个执行。其他不会执行。否则：<ul>
<li>如果有default子句，则执行该语句。</li>
<li>如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。</li>
</ul>
</li>
</ul>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>Go 只有一种循环结构——<code>for</code> 循环。基本的 for 循环除了没有了 <code>( )</code> 之外（甚至强制不能使用它们），看起来跟 C 或者 Java 中做的一样，而 <code>{ }</code> 是必须的。跟 C 或者 Java 中一样，可以让前置、后置语句为空。基于此可以省略分号：C 的 while 在 Go 中叫做 <code>for</code>。如果省略了循环条件，循环就不会结束，因此可以用更简洁地形式表达死循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 无限循环，类似于 while(1)</span></div><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">    block</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 相当于 while 循环</span></div><div class="line"><span class="keyword">for</span> booleanExpression &#123;</div><div class="line">    block</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 标准 for 循环</span></div><div class="line"><span class="keyword">for</span> optionalPrestatement; booleanExpress; optionalPostStatement &#123;</div><div class="line">    block</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 一个字符一个字符迭代字符串</span></div><div class="line"><span class="keyword">for</span> index, char := <span class="keyword">range</span> aString &#123;</div><div class="line">    block</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 一个字符一个字符迭代字符串</span></div><div class="line"><span class="keyword">for</span> index := <span class="keyword">range</span> aString &#123;</div><div class="line">    block <span class="comment">// char, size := utf8.DecodeRuneInString(aString[index:])</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 数组或者切片迭代</span></div><div class="line"><span class="keyword">for</span> index, item := <span class="keyword">range</span> anArrayOrSlice &#123;</div><div class="line">    block</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 数组或者切片迭代</span></div><div class="line"><span class="keyword">for</span> index := <span class="keyword">range</span> anArrayOrSlice &#123;</div><div class="line">    block <span class="comment">// item := anArrayOrSlice[index]</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 映射迭代</span></div><div class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> aMap &#123; </div><div class="line">    block</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 映射迭代</span></div><div class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> aMap &#123;</div><div class="line">    block <span class="comment">// value := aMap[key]</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 通道迭代</span></div><div class="line"><span class="keyword">for</span> item := <span class="keyword">range</span> aChannel &#123;</div><div class="line">    block</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="并发与通信"><a href="#并发与通信" class="headerlink" title="并发与通信"></a>并发与通信</h3><p>goroutine 是程序中与其他 goroutine 完全相互独立而并发执行的函数或者方法调用。每一个 Go 程序都至少有一个 goroutine，即会执行 <code>main</code> 包中的 <code>main()</code> 函数的主 goroutine。goroutine 非常像轻量级的线程或者协程，可以大批量被创建，并共享相同的地址空间，同时 Go 提供了锁原语来保证数据能够安全的跨 goroutine 共享。不过我们推荐使用通信来进行并发编程。</p>
<p>Go 语言的通道是一个双向或者单向的通信管道，它们可用于在两个或者多个 goroutine 之间通信。但是需要注意的是，优秀的程序员只有在并发程序带来的优点明显超过其所带来的负担才编写并发程序。</p>
<p>可以使用以下语句创建 goroutine：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">go</span> function(arguments)</div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(parameters)</span></span> &#123; block &#125; (arguments)</div></pre></td></tr></table></figure>
<p>被调用函数的执行会立即进行，但它是在另一个 goroutine 上执行，并且当前 goroutine 的执行会从下一条语句中立即恢复。不同 goroutine 协作的通信语法为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line">channel &lt;- value <span class="comment">// 阻塞发送</span></div><div class="line">&lt;- channel <span class="comment">// 接收并将其丢弃</span></div><div class="line">x := &lt;- channel <span class="comment">// 接收并将其保存</span></div><div class="line">x, ok := &lt;- channel <span class="comment">// 接收并将其保存，同时检查通道是否已关闭或者是否为空</span></div></pre></td></tr></table></figure>
<p>非阻塞的发送可以使用 <code>select</code> 语句来达到，或者在一些情况下使用带缓冲的通道。通道的创建语法为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> Type) <span class="comment">// 没有声明容量的通道是同步的，会阻塞直到发送者准备好发送以及</span></div><div class="line">                <span class="comment">// 接受者准备好接收</span></div><div class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> Type, capacity) <span class="comment">// 有容量的通道则是异步的</span></div></pre></td></tr></table></figure>
<p>我们来看一个简单的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">createCounter</span><span class="params">(start <span class="keyword">int</span>)</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</div><div class="line">    next := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</div><div class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">        <span class="keyword">for</span> &#123;</div><div class="line">            next &lt;- i</div><div class="line">            i++</div><div class="line">        &#125;</div><div class="line">    &#125; (start)</div><div class="line">    <span class="keyword">return</span> next</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">counterA := createCounter(<span class="number">2</span>)</div><div class="line">counterB := createCounter(<span class="number">102</span>)</div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</div><div class="line">    a := &lt;- counterA</div><div class="line">    fmt.Printf(<span class="string">"(A-&gt;%d, B-&gt;%d)"</span>, a, &lt;-counterB)</div><div class="line">&#125;</div><div class="line">fmt.Println()</div></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数可以没有参数或接受多个参数，注意类型名在变量名之后。当两个或多个连续函数的命名参数是同一类型，则除了最后一个类型之外，其他都可以省略，函数可以返回任意数量的返回值，比如 <code>swap</code> 函数</p>
<p>Go 的返回值可以被命名，并且像变量那样使用。返回值的名称应当具有一定的意义，可以作为文档使用。没有参数的 return 语句返回结果的当前值。也就是<code>直接</code>返回。直接返回语句仅应当用在像下面这样的短函数中。在长的函数中它们会影响代码的可读性。</p>
<p>在函数中，<code>:=</code> 简洁赋值语句在明确类型的地方，可以用于替代 var 定义。函数外的每个语句都必须以关键字开始（<code>var</code>、<code>func</code>、等等），<code>:=</code> 结构不能使用在函数外。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> c, python, java <span class="keyword">bool</span></div><div class="line"><span class="keyword">var</span> i, j <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> x + y</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">anotheradd</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> x + y</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> y, x</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">    x = sum * <span class="number">4</span> / <span class="number">9</span></div><div class="line">    y = sum - x</div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 可变参数</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">MinimumInt1</span><span class="params">(first <span class="keyword">int</span>, rest ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> rest &#123;</div><div class="line">        <span class="keyword">if</span> x &lt; first &#123;</div><div class="line">            first = x</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> first</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    fmt.Println(add(<span class="number">42</span>, <span class="number">13</span>))</div><div class="line">    a, b := swap(<span class="string">"hello"</span>, <span class="string">"world"</span>)</div><div class="line">    fmt.Println(a, b)</div><div class="line">    <span class="keyword">var</span> k <span class="keyword">int</span></div><div class="line">    fmt.Println(k, c, python, java)</div><div class="line">    fmt.Println(i, j)</div><div class="line">    y := <span class="number">3</span></div><div class="line">    cpp, ruby, scala := <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">"yes"</span></div><div class="line">    fmt.Println(y, cpp, ruby, scala)</div><div class="line">    fmt.Println(MinimumInt1(<span class="number">5</span>, <span class="number">3</span>), MinimumInt1(<span class="number">7</span>, <span class="number">3</span>, <span class="number">02</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">-8</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="defer-panic-和-recover"><a href="#defer-panic-和-recover" class="headerlink" title="defer, panic 和 recover"></a>defer, panic 和 recover</h3><p>defer 语句会延迟一个函数的执行，会在外围函数返回之前但是返回值计算之后执行。如果一个函数中有多个 defer 语句，会以后进先出的顺序执行，一个最常用的应用是用完文件后将其关闭。</p>
<p>Go 语言中的错误处理的惯用方法是将错误以函数或者方法的最后一个返回值的形式将其返回，并在调用它的地方检查返回的错误值。</p>
<p>而 <code>panic</code> 则用于处理那些『不可能』发生的事情，在早期开发阶段这是很好的特性，但是一旦上线运行，要尽量保证程序运行，就要配合 <code>recover</code> 使用。当 <code>panic()</code> 函数被调用时，外围函数或者方法的执行会立即中止，然后延迟执行的方法都会被调用。一层一层往上，直到 <code>main</code> 函数不再有可以返回的调用者，就把调用栈信息输出到 <code>os.Stderr</code>。在这个过程中，如果有一个延迟执行的函数中包含 <code>recover()</code> 函数，那么就回停止向上传播（不过我们建议还是手动调用 <code>panic()</code> 让其继续传播，或把一个 panic 转换成 error）</p>
<p>对于能够健壮地应多异常的 Web 服务器而言，我们必须保证每个页面响应函数都有一个调用 <code>recover()</code> 的匿名函数。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>您的支持是对我创作最大的鼓励！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/misc/wechat.jpg" alt="wdxtub WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/misc/alipay.jpg" alt="wdxtub Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/计算机/" rel="tag"># 计算机</a>
          
            <a href="/tags/初稿/" rel="tag"># 初稿</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/1984/09/11/ics-draft-2-1/" rel="next" title="【计算机系统导论】2.1 编码">
                <i class="fa fa-chevron-left"></i> 【计算机系统导论】2.1 编码
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/1984/09/11/ics-draft-2-3/" rel="prev" title="【计算机系统导论】2.3 信息表示">
                【计算机系统导论】2.3 信息表示 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="1984/09/11/ics-draft-2-2/"
     data-title="【计算机系统导论】2.2 编程语言"
     data-content=""
     data-url="http://wdxtub.com/1984/09/11/ics-draft-2-2/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          

  <p>热评文章</p>
  <div class="ds-top-threads" data-range="weekly" data-num-items="4"></div>


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="1984/09/11/ics-draft-2-2/"
           data-title="【计算机系统导论】2.2 编程语言" data-url="http://wdxtub.com/1984/09/11/ics-draft-2-2/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/misc/avatar.jpg"
               alt="wdxtub" />
          <p class="site-author-name" itemprop="name">wdxtub</p>
          <p class="site-description motion-element" itemprop="description">Engineer Blogger Creator Runner | ML DM NLP Web | 航拍 旅行 电影 音乐 | 有朋自远方来不亦乐乎 | @CMU @SYSU</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">816</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">942</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/wdxtub" target="_blank" title="GitHub">
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/wdxtub" target="_blank" title="微博">
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://douban.com/people/wdx" target="_blank" title="豆瓣">
                  
                  豆瓣
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/wdxtub" target="_blank" title="知乎">
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-nd.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              不妨看看
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://zhchbin.github.io/" title="zhchbin" target="_blank">zhchbin</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.algorithmdog.com/" title="算法狗" target="_blank">算法狗</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.52cs.org/" title="我爱计算机" target="_blank">我爱计算机</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://wdxtub.lofter.com/" title="我的 Lofter" target="_blank">我的 Lofter</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://wdxtub.com/interview/" title="刷题笔记" target="_blank">刷题笔记</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-1-编程迷思"><span class="nav-number">1.</span> <span class="nav-text">2.2.1 编程迷思</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#计算机不只是执行程序的机器"><span class="nav-number">1.1.</span> <span class="nav-text">计算机不只是执行程序的机器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#很多东西并不像看起来那样简单"><span class="nav-number">1.2.</span> <span class="nav-text">很多东西并不像看起来那样简单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存里多的是我们不知道的事"><span class="nav-number">1.3.</span> <span class="nav-text">内存里多的是我们不知道的事</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-2-罗素悖论"><span class="nav-number">2.</span> <span class="nav-text">2.2.2 罗素悖论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-3-实验环境配置"><span class="nav-number">3.</span> <span class="nav-text">2.2.3 实验环境配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux"><span class="nav-number">3.1.</span> <span class="nav-text">Linux</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mac"><span class="nav-number">3.2.</span> <span class="nav-text">Mac</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更新"><span class="nav-number">3.3.</span> <span class="nav-text">更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开发环境配置"><span class="nav-number">3.4.</span> <span class="nav-text">开发环境配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用命令"><span class="nav-number">3.5.</span> <span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hello-World"><span class="nav-number">3.6.</span> <span class="nav-text">Hello World</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-4-Go-语言快速入门"><span class="nav-number">4.</span> <span class="nav-text">2.2.4 Go 语言快速入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#整型与浮点数"><span class="nav-number">4.1.</span> <span class="nav-text">整型与浮点数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串"><span class="nav-number">4.2.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针"><span class="nav-number">4.3.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组与切片"><span class="nav-number">4.4.</span> <span class="nav-text">数组与切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#映射"><span class="nav-number">4.5.</span> <span class="nav-text">映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型转换与断言"><span class="nav-number">4.6.</span> <span class="nav-text">类型转换与断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分支语句"><span class="nav-number">4.7.</span> <span class="nav-text">分支语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环语句"><span class="nav-number">4.8.</span> <span class="nav-text">循环语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发与通信"><span class="nav-number">4.9.</span> <span class="nav-text">并发与通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数"><span class="nav-number">4.10.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defer-panic-和-recover"><span class="nav-number">4.11.</span> <span class="nav-text">defer, panic 和 recover</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2013 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wdxtub</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"wdxblog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      
      <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
      <script src="/js/src/hook-duoshuo.js?v=5.1.0"></script>
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  


</body>
</html>
